{"ast":null,"code":"import _defineProperty from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { m as isEndSide } from './helpers.js';\nvar itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}\";\nvar SWIPE_MARGIN = 30;\nvar ELASTIC_FACTOR = 0.55;\nvar openSlidingItem;\nvar ItemSliding = /*@__PURE__*/proxyCustomElement( /*#__PURE__*/function (_HTMLElement) {\n  _inherits(_class, _HTMLElement);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n\n    _this.__registerHost();\n\n    _this.ionDrag = createEvent(_assertThisInitialized(_this), \"ionDrag\", 7);\n    _this.item = null;\n    _this.openAmount = 0;\n    _this.initialOpenAmount = 0;\n    _this.optsWidthRightSide = 0;\n    _this.optsWidthLeftSide = 0;\n    _this.sides = 0\n    /* None */\n    ;\n    _this.optsDirty = true;\n    _this.closestContent = null;\n    _this.initialContentScrollY = true;\n    _this.state = 2\n    /* Disabled */\n    ;\n    /**\n     * If `true`, the user cannot interact with the sliding item.\n     */\n\n    _this.disabled = false;\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"disabledChanged\",\n    value: function disabledChanged() {\n      if (this.gesture) {\n        this.gesture.enable(!this.disabled);\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.item = this.el.querySelector('ion-item');\n                this.closestContent = this.el.closest('ion-content');\n                _context.next = 4;\n                return this.updateOptions();\n\n              case 4:\n                _context.next = 6;\n                return import('./index2.js');\n\n              case 6:\n                this.gesture = _context.sent.createGesture({\n                  el: this.el,\n                  gestureName: 'item-swipe',\n                  gesturePriority: 100,\n                  threshold: 5,\n                  canStart: function canStart(ev) {\n                    return _this2.canStart(ev);\n                  },\n                  onStart: function onStart() {\n                    return _this2.onStart();\n                  },\n                  onMove: function onMove(ev) {\n                    return _this2.onMove(ev);\n                  },\n                  onEnd: function onEnd(ev) {\n                    return _this2.onEnd(ev);\n                  }\n                });\n                this.disabledChanged();\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n\n      return connectedCallback;\n    }()\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n\n      this.item = null;\n      this.leftOptions = this.rightOptions = undefined;\n\n      if (openSlidingItem === this.el) {\n        openSlidingItem = undefined;\n      }\n    }\n    /**\n     * Get the amount the item is open in pixels.\n     */\n\n  }, {\n    key: \"getOpenAmount\",\n    value: function getOpenAmount() {\n      return Promise.resolve(this.openAmount);\n    }\n    /**\n     * Get the ratio of the open amount of the item compared to the width of the options.\n     * If the number returned is positive, then the options on the right side are open.\n     * If the number returned is negative, then the options on the left side are open.\n     * If the absolute value of the number is greater than 1, the item is open more than\n     * the width of the options.\n     */\n\n  }, {\n    key: \"getSlidingRatio\",\n    value: function getSlidingRatio() {\n      return Promise.resolve(this.getSlidingRatioSync());\n    }\n    /**\n     * Open the sliding item.\n     *\n     * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(side) {\n        var _this3 = this;\n\n        var optionsToOpen, isStartOpen, isEndOpen;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.item === null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                optionsToOpen = this.getOptions(side);\n\n                if (optionsToOpen) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                /**\n                 * If side is not set, we need to infer the side\n                 * so we know which direction to move the options\n                 */\n                if (side === undefined) {\n                  side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n                } // In RTL we want to switch the sides\n\n\n                side = isEndSide(side) ? 'end' : 'start';\n                isStartOpen = this.openAmount < 0;\n                isEndOpen = this.openAmount > 0;\n                /**\n                 * If a side is open and a user tries to\n                 * re-open the same side, we should not do anything\n                 */\n\n                if (!(isStartOpen && optionsToOpen === this.leftOptions)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 11:\n                if (!(isEndOpen && optionsToOpen === this.rightOptions)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 13:\n                this.closeOpened();\n                this.state = 4\n                /* Enabled */\n                ;\n                requestAnimationFrame(function () {\n                  _this3.calculateOptsWidth();\n\n                  var width = side === 'end' ? _this3.optsWidthRightSide : -_this3.optsWidthLeftSide;\n                  openSlidingItem = _this3.el;\n\n                  _this3.setOpenAmount(width, false);\n\n                  _this3.state = side === 'end' ? 8\n                  /* End */\n                  : 16\n                  /* Start */\n                  ;\n                });\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Close the sliding item. Items can also be closed from the [List](./list).\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.setOpenAmount(0, true);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\n     */\n\n  }, {\n    key: \"closeOpened\",\n    value: function () {\n      var _closeOpened = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(openSlidingItem !== undefined)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                openSlidingItem.close();\n                openSlidingItem = undefined;\n                return _context4.abrupt(\"return\", true);\n\n              case 4:\n                return _context4.abrupt(\"return\", false);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function closeOpened() {\n        return _closeOpened.apply(this, arguments);\n      }\n\n      return closeOpened;\n    }()\n    /**\n     * Given an optional side, return the ion-item-options element.\n     *\n     * @param side This side of the options to get. If a side is not provided it will\n     * return the first one available.\n     */\n\n  }, {\n    key: \"getOptions\",\n    value: function getOptions(side) {\n      if (side === undefined) {\n        return this.leftOptions || this.rightOptions;\n      } else if (side === 'start') {\n        return this.leftOptions;\n      } else {\n        return this.rightOptions;\n      }\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function () {\n      var _updateOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var options, sides, i, item, option, side;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = this.el.querySelectorAll('ion-item-options');\n                sides = 0; // Reset left and right options in case they were removed\n\n                this.leftOptions = this.rightOptions = undefined;\n                i = 0;\n\n              case 4:\n                if (!(i < options.length)) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                item = options.item(i);\n                /**\n                 * We cannot use the componentOnReady helper\n                 * util here since we need to wait for all of these items\n                 * to be ready before we set `this.sides` and `this.optsDirty`.\n                 */\n\n                if (!(item.componentOnReady !== undefined)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.next = 9;\n                return item.componentOnReady();\n\n              case 9:\n                _context5.t0 = _context5.sent;\n                _context5.next = 13;\n                break;\n\n              case 12:\n                _context5.t0 = item;\n\n              case 13:\n                option = _context5.t0;\n                side = isEndSide(option.side) ? 'end' : 'start';\n\n                if (side === 'start') {\n                  this.leftOptions = option;\n                  sides |= 1\n                  /* Start */\n                  ;\n                } else {\n                  this.rightOptions = option;\n                  sides |= 2\n                  /* End */\n                  ;\n                }\n\n              case 16:\n                i++;\n                _context5.next = 4;\n                break;\n\n              case 19:\n                this.optsDirty = true;\n                this.sides = sides;\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function updateOptions() {\n        return _updateOptions.apply(this, arguments);\n      }\n\n      return updateOptions;\n    }()\n  }, {\n    key: \"canStart\",\n    value: function canStart(gesture) {\n      /**\n       * If very close to start of the screen\n       * do not open left side so swipe to go\n       * back will still work.\n       */\n      var rtl = document.dir === 'rtl';\n      var atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n\n      if (atEdge) {\n        return false;\n      }\n\n      var selected = openSlidingItem;\n\n      if (selected && selected !== this.el) {\n        this.closeOpened();\n      }\n\n      return !!(this.rightOptions || this.leftOptions);\n    }\n  }, {\n    key: \"disableContentScrollY\",\n    value: function disableContentScrollY() {\n      if (this.closestContent === null) {\n        return;\n      }\n\n      this.initialContentScrollY = this.closestContent.scrollY;\n      this.closestContent.scrollY = false;\n    }\n  }, {\n    key: \"restoreContentScrollY\",\n    value: function restoreContentScrollY() {\n      if (this.closestContent === null) {\n        return;\n      }\n\n      this.closestContent.scrollY = this.initialContentScrollY;\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart() {\n      /**\n       * We need to query for the ion-item\n       * every time the gesture starts. Developers\n       * may toggle ion-item elements via *ngIf.\n       */\n      this.item = this.el.querySelector('ion-item'); // Prevent scrolling during gesture\n\n      this.disableContentScrollY();\n      openSlidingItem = this.el;\n\n      if (this.tmr !== undefined) {\n        clearTimeout(this.tmr);\n        this.tmr = undefined;\n      }\n\n      if (this.openAmount === 0) {\n        this.optsDirty = true;\n        this.state = 4\n        /* Enabled */\n        ;\n      }\n\n      this.initialOpenAmount = this.openAmount;\n\n      if (this.item) {\n        this.item.style.transition = 'none';\n      }\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(gesture) {\n      if (this.optsDirty) {\n        this.calculateOptsWidth();\n      }\n\n      var openAmount = this.initialOpenAmount - gesture.deltaX;\n\n      switch (this.sides) {\n        case 2\n        /* End */\n        :\n          openAmount = Math.max(0, openAmount);\n          break;\n\n        case 1\n        /* Start */\n        :\n          openAmount = Math.min(0, openAmount);\n          break;\n\n        case 3\n        /* Both */\n        :\n          break;\n\n        case 0\n        /* None */\n        :\n          return;\n\n        default:\n          console.warn('invalid ItemSideFlags value', this.sides);\n          break;\n      }\n\n      var optsWidth;\n\n      if (openAmount > this.optsWidthRightSide) {\n        optsWidth = this.optsWidthRightSide;\n        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n      } else if (openAmount < -this.optsWidthLeftSide) {\n        optsWidth = -this.optsWidthLeftSide;\n        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n      }\n\n      this.setOpenAmount(openAmount, false);\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(gesture) {\n      // Restore ion-content scrollY to initial value when gesture ends\n      this.restoreContentScrollY();\n      var velocity = gesture.velocityX;\n      var restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide; // Check if the drag didn't clear the buttons mid-point\n      // and we aren't moving fast enough to swipe open\n\n      var isResetDirection = this.openAmount > 0 === !(velocity < 0);\n      var isMovingFast = Math.abs(velocity) > 0.3;\n      var isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n\n      if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n        restingPoint = 0;\n      }\n\n      var state = this.state;\n      this.setOpenAmount(restingPoint, true);\n\n      if ((state & 32\n      /* SwipeEnd */\n      ) !== 0 && this.rightOptions) {\n        this.rightOptions.fireSwipeEvent();\n      } else if ((state & 64\n      /* SwipeStart */\n      ) !== 0 && this.leftOptions) {\n        this.leftOptions.fireSwipeEvent();\n      }\n    }\n  }, {\n    key: \"calculateOptsWidth\",\n    value: function calculateOptsWidth() {\n      this.optsWidthRightSide = 0;\n\n      if (this.rightOptions) {\n        this.rightOptions.style.display = 'flex';\n        this.optsWidthRightSide = this.rightOptions.offsetWidth;\n        this.rightOptions.style.display = '';\n      }\n\n      this.optsWidthLeftSide = 0;\n\n      if (this.leftOptions) {\n        this.leftOptions.style.display = 'flex';\n        this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n        this.leftOptions.style.display = '';\n      }\n\n      this.optsDirty = false;\n    }\n  }, {\n    key: \"setOpenAmount\",\n    value: function setOpenAmount(openAmount, isFinal) {\n      var _this4 = this;\n\n      if (this.tmr !== undefined) {\n        clearTimeout(this.tmr);\n        this.tmr = undefined;\n      }\n\n      if (!this.item) {\n        return;\n      }\n\n      var style = this.item.style;\n      this.openAmount = openAmount;\n\n      if (isFinal) {\n        style.transition = '';\n      }\n\n      if (openAmount > 0) {\n        this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8\n        /* End */\n        | 32\n        /* SwipeEnd */\n        : 8\n        /* End */\n        ;\n      } else if (openAmount < 0) {\n        this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16\n        /* Start */\n        | 64\n        /* SwipeStart */\n        : 16\n        /* Start */\n        ;\n      } else {\n        /**\n         * Item sliding cannot be interrupted\n         * while closing the item. If it did,\n         * it would allow the item to get into an\n         * inconsistent state where multiple\n         * items are then open at the same time.\n         */\n        if (this.gesture) {\n          this.gesture.enable(false);\n        }\n\n        this.tmr = setTimeout(function () {\n          _this4.state = 2\n          /* Disabled */\n          ;\n          _this4.tmr = undefined;\n\n          if (_this4.gesture) {\n            _this4.gesture.enable(!_this4.disabled);\n          }\n        }, 600);\n        openSlidingItem = undefined;\n        style.transform = '';\n        return;\n      }\n\n      style.transform = \"translate3d(\".concat(-openAmount, \"px,0,0)\");\n      this.ionDrag.emit({\n        amount: openAmount,\n        ratio: this.getSlidingRatioSync()\n      });\n    }\n  }, {\n    key: \"getSlidingRatioSync\",\n    value: function getSlidingRatioSync() {\n      if (this.openAmount > 0) {\n        return this.openAmount / this.optsWidthRightSide;\n      } else if (this.openAmount < 0) {\n        return this.openAmount / this.optsWidthLeftSide;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _class2;\n\n      var mode = getIonMode(this);\n      return h(Host, {\n        class: (_class2 = {}, _defineProperty(_class2, mode, true), _defineProperty(_class2, 'item-sliding-active-slide', this.state !== 2), _defineProperty(_class2, 'item-sliding-active-options-end', (this.state & 8\n        /* End */\n        ) !== 0), _defineProperty(_class2, 'item-sliding-active-options-start', (this.state & 16\n        /* Start */\n        ) !== 0), _defineProperty(_class2, 'item-sliding-active-swipe-end', (this.state & 32\n        /* SwipeEnd */\n        ) !== 0), _defineProperty(_class2, 'item-sliding-active-swipe-start', (this.state & 64\n        /* SwipeStart */\n        ) !== 0), _class2)\n      });\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"disabled\": [\"disabledChanged\"]\n      };\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return itemSlidingCss;\n    }\n  }]);\n\n  return _class;\n}(HTMLElement), [0, \"ion-item-sliding\", {\n  \"disabled\": [4],\n  \"state\": [32],\n  \"getOpenAmount\": [64],\n  \"getSlidingRatio\": [64],\n  \"open\": [64],\n  \"close\": [64],\n  \"closeOpened\": [64]\n}]);\n\nvar swipeShouldReset = function swipeShouldReset(isResetDirection, isMovingFast, isOnResetZone) {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return !isMovingFast && isOnResetZone || isResetDirection && isMovingFast;\n};\n\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n\n  var components = [\"ion-item-sliding\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-item-sliding\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, ItemSliding);\n        }\n\n        break;\n    }\n  });\n}\n\nvar IonItemSliding = ItemSliding;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonItemSliding, defineCustomElement };","map":{"version":3,"sources":["/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@ionic/core/components/ion-item-sliding.js"],"names":["proxyCustomElement","HTMLElement","createEvent","h","Host","b","getIonMode","m","isEndSide","itemSlidingCss","SWIPE_MARGIN","ELASTIC_FACTOR","openSlidingItem","ItemSliding","__registerHost","ionDrag","item","openAmount","initialOpenAmount","optsWidthRightSide","optsWidthLeftSide","sides","optsDirty","closestContent","initialContentScrollY","state","disabled","gesture","enable","el","querySelector","closest","updateOptions","createGesture","gestureName","gesturePriority","threshold","canStart","ev","onStart","onMove","onEnd","disabledChanged","destroy","undefined","leftOptions","rightOptions","Promise","resolve","getSlidingRatioSync","side","optionsToOpen","getOptions","isStartOpen","isEndOpen","closeOpened","requestAnimationFrame","calculateOptsWidth","width","setOpenAmount","close","options","querySelectorAll","i","length","componentOnReady","option","rtl","document","dir","atEdge","window","innerWidth","startX","selected","scrollY","disableContentScrollY","tmr","clearTimeout","style","transition","deltaX","Math","max","min","console","warn","optsWidth","restoreContentScrollY","velocity","velocityX","restingPoint","isResetDirection","isMovingFast","abs","isOnCloseZone","swipeShouldReset","fireSwipeEvent","display","offsetWidth","isFinal","setTimeout","transform","emit","amount","ratio","mode","class","isOnResetZone","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonItemSliding","defineCustomElement"],"mappings":"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","sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { m as isEndSide } from './helpers.js';\n\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}\";\n\nconst SWIPE_MARGIN = 30;\nconst ELASTIC_FACTOR = 0.55;\nlet openSlidingItem;\nconst ItemSliding = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionDrag = createEvent(this, \"ionDrag\", 7);\n    this.item = null;\n    this.openAmount = 0;\n    this.initialOpenAmount = 0;\n    this.optsWidthRightSide = 0;\n    this.optsWidthLeftSide = 0;\n    this.sides = 0 /* None */;\n    this.optsDirty = true;\n    this.closestContent = null;\n    this.initialContentScrollY = true;\n    this.state = 2 /* Disabled */;\n    /**\n     * If `true`, the user cannot interact with the sliding item.\n     */\n    this.disabled = false;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    this.item = this.el.querySelector('ion-item');\n    this.closestContent = this.el.closest('ion-content');\n    await this.updateOptions();\n    this.gesture = (await import('./index2.js')).createGesture({\n      el: this.el,\n      gestureName: 'item-swipe',\n      gesturePriority: 100,\n      threshold: 5,\n      canStart: (ev) => this.canStart(ev),\n      onStart: () => this.onStart(),\n      onMove: (ev) => this.onMove(ev),\n      onEnd: (ev) => this.onEnd(ev),\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.item = null;\n    this.leftOptions = this.rightOptions = undefined;\n    if (openSlidingItem === this.el) {\n      openSlidingItem = undefined;\n    }\n  }\n  /**\n   * Get the amount the item is open in pixels.\n   */\n  getOpenAmount() {\n    return Promise.resolve(this.openAmount);\n  }\n  /**\n   * Get the ratio of the open amount of the item compared to the width of the options.\n   * If the number returned is positive, then the options on the right side are open.\n   * If the number returned is negative, then the options on the left side are open.\n   * If the absolute value of the number is greater than 1, the item is open more than\n   * the width of the options.\n   */\n  getSlidingRatio() {\n    return Promise.resolve(this.getSlidingRatioSync());\n  }\n  /**\n   * Open the sliding item.\n   *\n   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n   */\n  async open(side) {\n    if (this.item === null) {\n      return;\n    }\n    const optionsToOpen = this.getOptions(side);\n    if (!optionsToOpen) {\n      return;\n    }\n    /**\n     * If side is not set, we need to infer the side\n     * so we know which direction to move the options\n     */\n    if (side === undefined) {\n      side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n    }\n    // In RTL we want to switch the sides\n    side = isEndSide(side) ? 'end' : 'start';\n    const isStartOpen = this.openAmount < 0;\n    const isEndOpen = this.openAmount > 0;\n    /**\n     * If a side is open and a user tries to\n     * re-open the same side, we should not do anything\n     */\n    if (isStartOpen && optionsToOpen === this.leftOptions) {\n      return;\n    }\n    if (isEndOpen && optionsToOpen === this.rightOptions) {\n      return;\n    }\n    this.closeOpened();\n    this.state = 4 /* Enabled */;\n    requestAnimationFrame(() => {\n      this.calculateOptsWidth();\n      const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n      openSlidingItem = this.el;\n      this.setOpenAmount(width, false);\n      this.state = side === 'end' ? 8 /* End */ : 16 /* Start */;\n    });\n  }\n  /**\n   * Close the sliding item. Items can also be closed from the [List](./list).\n   */\n  async close() {\n    this.setOpenAmount(0, true);\n  }\n  /**\n   * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\n   */\n  async closeOpened() {\n    if (openSlidingItem !== undefined) {\n      openSlidingItem.close();\n      openSlidingItem = undefined;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Given an optional side, return the ion-item-options element.\n   *\n   * @param side This side of the options to get. If a side is not provided it will\n   * return the first one available.\n   */\n  getOptions(side) {\n    if (side === undefined) {\n      return this.leftOptions || this.rightOptions;\n    }\n    else if (side === 'start') {\n      return this.leftOptions;\n    }\n    else {\n      return this.rightOptions;\n    }\n  }\n  async updateOptions() {\n    const options = this.el.querySelectorAll('ion-item-options');\n    let sides = 0;\n    // Reset left and right options in case they were removed\n    this.leftOptions = this.rightOptions = undefined;\n    for (let i = 0; i < options.length; i++) {\n      const item = options.item(i);\n      /**\n       * We cannot use the componentOnReady helper\n       * util here since we need to wait for all of these items\n       * to be ready before we set `this.sides` and `this.optsDirty`.\n       */\n      const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;\n      const side = isEndSide(option.side) ? 'end' : 'start';\n      if (side === 'start') {\n        this.leftOptions = option;\n        sides |= 1 /* Start */;\n      }\n      else {\n        this.rightOptions = option;\n        sides |= 2 /* End */;\n      }\n    }\n    this.optsDirty = true;\n    this.sides = sides;\n  }\n  canStart(gesture) {\n    /**\n     * If very close to start of the screen\n     * do not open left side so swipe to go\n     * back will still work.\n     */\n    const rtl = document.dir === 'rtl';\n    const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n    if (atEdge) {\n      return false;\n    }\n    const selected = openSlidingItem;\n    if (selected && selected !== this.el) {\n      this.closeOpened();\n    }\n    return !!(this.rightOptions || this.leftOptions);\n  }\n  disableContentScrollY() {\n    if (this.closestContent === null) {\n      return;\n    }\n    this.initialContentScrollY = this.closestContent.scrollY;\n    this.closestContent.scrollY = false;\n  }\n  restoreContentScrollY() {\n    if (this.closestContent === null) {\n      return;\n    }\n    this.closestContent.scrollY = this.initialContentScrollY;\n  }\n  onStart() {\n    /**\n     * We need to query for the ion-item\n     * every time the gesture starts. Developers\n     * may toggle ion-item elements via *ngIf.\n     */\n    this.item = this.el.querySelector('ion-item');\n    // Prevent scrolling during gesture\n    this.disableContentScrollY();\n    openSlidingItem = this.el;\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (this.openAmount === 0) {\n      this.optsDirty = true;\n      this.state = 4 /* Enabled */;\n    }\n    this.initialOpenAmount = this.openAmount;\n    if (this.item) {\n      this.item.style.transition = 'none';\n    }\n  }\n  onMove(gesture) {\n    if (this.optsDirty) {\n      this.calculateOptsWidth();\n    }\n    let openAmount = this.initialOpenAmount - gesture.deltaX;\n    switch (this.sides) {\n      case 2 /* End */:\n        openAmount = Math.max(0, openAmount);\n        break;\n      case 1 /* Start */:\n        openAmount = Math.min(0, openAmount);\n        break;\n      case 3 /* Both */:\n        break;\n      case 0 /* None */:\n        return;\n      default:\n        console.warn('invalid ItemSideFlags value', this.sides);\n        break;\n    }\n    let optsWidth;\n    if (openAmount > this.optsWidthRightSide) {\n      optsWidth = this.optsWidthRightSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    else if (openAmount < -this.optsWidthLeftSide) {\n      optsWidth = -this.optsWidthLeftSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    this.setOpenAmount(openAmount, false);\n  }\n  onEnd(gesture) {\n    // Restore ion-content scrollY to initial value when gesture ends\n    this.restoreContentScrollY();\n    const velocity = gesture.velocityX;\n    let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    const isResetDirection = this.openAmount > 0 === !(velocity < 0);\n    const isMovingFast = Math.abs(velocity) > 0.3;\n    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n      restingPoint = 0;\n    }\n    const state = this.state;\n    this.setOpenAmount(restingPoint, true);\n    if ((state & 32 /* SwipeEnd */) !== 0 && this.rightOptions) {\n      this.rightOptions.fireSwipeEvent();\n    }\n    else if ((state & 64 /* SwipeStart */) !== 0 && this.leftOptions) {\n      this.leftOptions.fireSwipeEvent();\n    }\n  }\n  calculateOptsWidth() {\n    this.optsWidthRightSide = 0;\n    if (this.rightOptions) {\n      this.rightOptions.style.display = 'flex';\n      this.optsWidthRightSide = this.rightOptions.offsetWidth;\n      this.rightOptions.style.display = '';\n    }\n    this.optsWidthLeftSide = 0;\n    if (this.leftOptions) {\n      this.leftOptions.style.display = 'flex';\n      this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n      this.leftOptions.style.display = '';\n    }\n    this.optsDirty = false;\n  }\n  setOpenAmount(openAmount, isFinal) {\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (!this.item) {\n      return;\n    }\n    const style = this.item.style;\n    this.openAmount = openAmount;\n    if (isFinal) {\n      style.transition = '';\n    }\n    if (openAmount > 0) {\n      this.state =\n        openAmount >= this.optsWidthRightSide + SWIPE_MARGIN\n          ? 8 /* End */ | 32 /* SwipeEnd */\n          : 8 /* End */;\n    }\n    else if (openAmount < 0) {\n      this.state =\n        openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN\n          ? 16 /* Start */ | 64 /* SwipeStart */\n          : 16 /* Start */;\n    }\n    else {\n      /**\n       * Item sliding cannot be interrupted\n       * while closing the item. If it did,\n       * it would allow the item to get into an\n       * inconsistent state where multiple\n       * items are then open at the same time.\n       */\n      if (this.gesture) {\n        this.gesture.enable(false);\n      }\n      this.tmr = setTimeout(() => {\n        this.state = 2 /* Disabled */;\n        this.tmr = undefined;\n        if (this.gesture) {\n          this.gesture.enable(!this.disabled);\n        }\n      }, 600);\n      openSlidingItem = undefined;\n      style.transform = '';\n      return;\n    }\n    style.transform = `translate3d(${-openAmount}px,0,0)`;\n    this.ionDrag.emit({\n      amount: openAmount,\n      ratio: this.getSlidingRatioSync(),\n    });\n  }\n  getSlidingRatioSync() {\n    if (this.openAmount > 0) {\n      return this.openAmount / this.optsWidthRightSide;\n    }\n    else if (this.openAmount < 0) {\n      return this.openAmount / this.optsWidthLeftSide;\n    }\n    else {\n      return 0;\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'item-sliding-active-slide': this.state !== 2 /* Disabled */,\n        'item-sliding-active-options-end': (this.state & 8 /* End */) !== 0,\n        'item-sliding-active-options-start': (this.state & 16 /* Start */) !== 0,\n        'item-sliding-active-swipe-end': (this.state & 32 /* SwipeEnd */) !== 0,\n        'item-sliding-active-swipe-start': (this.state & 64 /* SwipeStart */) !== 0,\n      } }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n  static get style() { return itemSlidingCss; }\n}, [0, \"ion-item-sliding\", {\n    \"disabled\": [4],\n    \"state\": [32],\n    \"getOpenAmount\": [64],\n    \"getSlidingRatio\": [64],\n    \"open\": [64],\n    \"close\": [64],\n    \"closeOpened\": [64]\n  }]);\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item-sliding\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-item-sliding\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, ItemSliding);\n      }\n      break;\n  } });\n}\n\nconst IonItemSliding = ItemSliding;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonItemSliding, defineCustomElement };\n"]},"metadata":{},"sourceType":"module"}