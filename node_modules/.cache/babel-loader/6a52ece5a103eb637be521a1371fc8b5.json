{"ast":null,"code":"/*\nfunction Camera() {\n    return(\n        <div className='camera'>\n            <label>\n                <input  id=\"camera\"\n                        style={{display: 'none'}}\n                        type=\"file\" \n                        accept=\"image/*\"\n                        capture=\"camera\"\n                        onChange={readURL(this)}\n                />\n                Camera\n            </label>\n        </div>\n    );\n}\n\nfunction saveImage() {\n    const input = document.getElementById('camera');\n\n    if (input != null){\n        input.onchange = (function(e) {\n            const file = e.path[0].files[0];\n            var image = document.createElement('img');\n            const reader = new FileReader();\n\n            reader.onload = function(event) {\n                image.src = event.target.result;\n            };\n\n            reader.readAsDataURL(file);\n            document.getElementById(\"popup\").appendChild(image);\n        });\n    }\n}\n\nfunction readURL(input){\n    var image = document.createElement('img');\n\n    //console.log(input);\n    \n    if (input !== undefined) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n            image.src = e.target.result;\n        }\n       \n        reader.readAsDataURL(input.files[0]);\n        document.getElementById(\"popup\").appendChild(image);\n    }\n}\n\n*/\n\n/*\nfunction CameraContainer() {\n    return (\n        <div>\n            <button id=\"camera\">Camera</button>\n            <video autoplay></video>\n            <script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"></script>\n        </div>\n    )\n}\n\nfunction CameraOnClick() {\n    document.querySelector('#camera').addEventListener('click', async function init(e) {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: true\n          })\n          const videoTracks = stream.getVideoTracks()\n          const track = videoTracks[0]\n          alert(`Getting video from: ${track.label}`)\n          document.querySelector('video').srcObject = stream\n          document.querySelector('#camera').setAttribute('hidden', true)\n        } catch (error) {\n          alert(`${error.name}`)\n          console.error(error)\n        }\n    })\n}\n\nvar takePhotoButton = document.querySelector('button#takePhoto');\nvar canvas = document.querySelector('canvas');\n\ntakePhotoButton.onclick = takePhoto;\n\n// Get a Blob from the currently selected camera source and\n// display this with an img element.\nfunction takePhoto() {\n  imageCapture.takePhoto().then(function(blob) {\n    console.log('Took photo:', blob);\n    img.classList.remove('hidden');\n    img.src = URL.createObjectURL(blob);\n  }).catch(function(error) {\n    console.log('takePhoto() error: ', error);\n  });\n}\n\nexport default Camera\n*/\n\n/*\n//const Camera = () => {\n    // The width and height of the captured photo. We will set the\n    // width to the value defined here, but the height will be\n    // calculated based on the aspect ratio of the input stream.\n  \n    var width = 320;    // We will scale the photo width to this\n    var height = 0;     // This will be computed based on the input stream\n  \n    // |streaming| indicates whether or not we're currently streaming\n    // video from the camera. Obviously, we start at false.\n  \n    var streaming = false;\n  \n    // The various HTML elements we need to configure or control. These\n    // will be set by the startup() function.\n  \n    var video = null;\n    var canvas = null;\n    var photo = null;\n    var startbutton = null;\n  \n    function startup() {\n      video = document.getElementById(\"video\");\n      canvas = document.createElement(\"canvas\");\n      photo = document.createElement(\"img\");\n      startbutton = document.getElementById(\"startbutton\");\n  \n      navigator.mediaDevices.getUserMedia({video: true, audio: false})\n      .then(function(stream) {\n        video.srcObject = stream;\n        video.play();\n      })\n      .catch(function(err) {\n        console.log(\"An error occurred: \" + err);\n      });\n      \n      video.addEventListener('canplay', function(ev){\n        if (!streaming) {\n          height = video.videoHeight / (video.videoWidth/width);\n        \n          // Firefox currently has a bug where the height can't be read from\n          // the video, so we will make assumptions if this happens.\n        \n          if (isNaN(height)) {\n            height = width / (4/3);\n          }\n        \n          video.setAttribute('width', width);\n          video.setAttribute('height', height);\n          canvas.setAttribute('width', width);\n          canvas.setAttribute('height', height);\n          streaming = true;\n        }\n      }, false);\n  \n      startbutton.addEventListener('click', function(ev){\n        takepicture();\n        ev.preventDefault();\n      }, false);\n      \n      clearphoto();\n    }\n  \n    // Fill the photo with an indication that none has been\n    // captured.\n  \n    function clearphoto() {\n      var context = canvas.getContext('2d');\n      context.fillStyle = \"#AAA\";\n      context.fillRect(0, 0, canvas.width, canvas.height);\n  \n      var data = canvas.toDataURL('image/png');\n      photo.setAttribute('src', data);\n    }\n    \n    // Capture a photo by fetching the current contents of the video\n    // and drawing it into a canvas, then converting that to a PNG\n    // format data URL. By drawing it on an offscreen canvas and then\n    // drawing that to the screen, we can change its size and/or apply\n    // other changes before drawing it.\n  \n    function takepicture() {\n      var context = canvas.getContext('2d');\n      if (width && height) {\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n      \n        var data = canvas.toDataURL('image/png');\n        photo.setAttribute('src', data);\n      } else {\n        clearphoto();\n      }\n    }\n  \n    // Set up our event listener to run the startup process\n    // once loading is complete.\n    //window.addEventListener('load', startup, false);\n  //};\n  \n  export default startup\n\n  */\nconst controls = document.getElementById('controls');\nconsole.log(controls);\nconst cameraOptions = document.querySelector('.video-options>select');\nconsole.log(cameraOptions);\nconst video = document.querySelector('video');\nconsole.log(video);\nconst canvas = document.querySelector('canvas');\nconst screenshotImage = document.querySelector('img');\nconst buttons = [...controls.querySelectorAll('button')];\nlet streamStarted = false;\nconst [play, pause, screenshot] = buttons;\nconst constraints = {\n  video: {\n    width: {\n      min: 1280,\n      ideal: 1920,\n      max: 2560\n    },\n    height: {\n      min: 720,\n      ideal: 1080,\n      max: 1440\n    }\n  }\n};\n\ncameraOptions.onchange = () => {\n  const updatedConstraints = { ...constraints,\n    deviceId: {\n      exact: cameraOptions.value\n    }\n  };\n  startStream(updatedConstraints);\n};\n\nplay.onclick = () => {\n  if (streamStarted) {\n    video.play();\n    play.classList.add('d-none');\n    pause.classList.remove('d-none');\n    return;\n  }\n\n  if ('mediaDevices' in navigator && navigator.mediaDevices.getUserMedia) {\n    const updatedConstraints = { ...constraints,\n      deviceId: {\n        exact: cameraOptions.value\n      }\n    };\n    startStream(updatedConstraints);\n  }\n};\n\nconst pauseStream = () => {\n  video.pause();\n  play.classList.remove('d-none');\n  pause.classList.add('d-none');\n};\n\nconst doScreenshot = () => {\n  canvas.width = video.videoWidth;\n  canvas.height = video.videoHeight;\n  canvas.getContext('2d').drawImage(video, 0, 0);\n  screenshotImage.src = canvas.toDataURL('image/webp');\n  screenshotImage.classList.remove('d-none');\n};\n\npause.onclick = pauseStream;\nscreenshot.onclick = doScreenshot;\n\nconst startStream = async constraints => {\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  handleStream(stream);\n};\n\nconst handleStream = stream => {\n  video.srcObject = stream;\n  play.classList.add('d-none');\n  pause.classList.remove('d-none');\n  screenshot.classList.remove('d-none');\n};\n\nconst getCameraSelection = async () => {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const videoDevices = devices.filter(device => device.kind === 'videoinput');\n  const options = videoDevices.map(videoDevice => {\n    return `<option value=\"${videoDevice.deviceId}\">${videoDevice.label}</option>`;\n  });\n  cameraOptions.innerHTML = options.join('');\n};\n\ngetCameraSelection();","map":{"version":3,"sources":["/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/src/Camera.js"],"names":["controls","document","getElementById","console","log","cameraOptions","querySelector","video","canvas","screenshotImage","buttons","querySelectorAll","streamStarted","play","pause","screenshot","constraints","width","min","ideal","max","height","onchange","updatedConstraints","deviceId","exact","value","startStream","onclick","classList","add","remove","navigator","mediaDevices","getUserMedia","pauseStream","doScreenshot","videoWidth","videoHeight","getContext","drawImage","src","toDataURL","stream","handleStream","srcObject","getCameraSelection","devices","enumerateDevices","videoDevices","filter","device","kind","options","map","videoDevice","label","innerHTML","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,MAAMA,QAAQ,GAAGC,QAAQ,CAACC,cAAT,CAAwB,UAAxB,CAAjB;AACAC,OAAO,CAACC,GAAR,CAAYJ,QAAZ;AACA,MAAMK,aAAa,GAAGJ,QAAQ,CAACK,aAAT,CAAuB,uBAAvB,CAAtB;AACAH,OAAO,C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","sourcesContent":["/*\nfunction Camera() {\n    return(\n        <div className='camera'>\n            <label>\n                <input  id=\"camera\"\n                        style={{display: 'none'}}\n                        type=\"file\" \n                        accept=\"image/*\"\n                        capture=\"camera\"\n                        onChange={readURL(this)}\n                />\n                Camera\n            </label>\n        </div>\n    );\n}\n\nfunction saveImage() {\n    const input = document.getElementById('camera');\n\n    if (input != null){\n        input.onchange = (function(e) {\n            const file = e.path[0].files[0];\n            var image = document.createElement('img');\n            const reader = new FileReader();\n\n            reader.onload = function(event) {\n                image.src = event.target.result;\n            };\n\n            reader.readAsDataURL(file);\n            document.getElementById(\"popup\").appendChild(image);\n        });\n    }\n}\n\nfunction readURL(input){\n    var image = document.createElement('img');\n\n    //console.log(input);\n    \n    if (input !== undefined) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n            image.src = e.target.result;\n        }\n       \n        reader.readAsDataURL(input.files[0]);\n        document.getElementById(\"popup\").appendChild(image);\n    }\n}\n\n*/\n\n/*\nfunction CameraContainer() {\n    return (\n        <div>\n            <button id=\"camera\">Camera</button>\n            <video autoplay></video>\n            <script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"></script>\n        </div>\n    )\n}\n\nfunction CameraOnClick() {\n    document.querySelector('#camera').addEventListener('click', async function init(e) {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: true\n          })\n          const videoTracks = stream.getVideoTracks()\n          const track = videoTracks[0]\n          alert(`Getting video from: ${track.label}`)\n          document.querySelector('video').srcObject = stream\n          document.querySelector('#camera').setAttribute('hidden', true)\n        } catch (error) {\n          alert(`${error.name}`)\n          console.error(error)\n        }\n    })\n}\n\nvar takePhotoButton = document.querySelector('button#takePhoto');\nvar canvas = document.querySelector('canvas');\n\ntakePhotoButton.onclick = takePhoto;\n\n// Get a Blob from the currently selected camera source and\n// display this with an img element.\nfunction takePhoto() {\n  imageCapture.takePhoto().then(function(blob) {\n    console.log('Took photo:', blob);\n    img.classList.remove('hidden');\n    img.src = URL.createObjectURL(blob);\n  }).catch(function(error) {\n    console.log('takePhoto() error: ', error);\n  });\n}\n\nexport default Camera\n*/\n\n\n\n\n\n/*\n//const Camera = () => {\n    // The width and height of the captured photo. We will set the\n    // width to the value defined here, but the height will be\n    // calculated based on the aspect ratio of the input stream.\n  \n    var width = 320;    // We will scale the photo width to this\n    var height = 0;     // This will be computed based on the input stream\n  \n    // |streaming| indicates whether or not we're currently streaming\n    // video from the camera. Obviously, we start at false.\n  \n    var streaming = false;\n  \n    // The various HTML elements we need to configure or control. These\n    // will be set by the startup() function.\n  \n    var video = null;\n    var canvas = null;\n    var photo = null;\n    var startbutton = null;\n  \n    function startup() {\n      video = document.getElementById(\"video\");\n      canvas = document.createElement(\"canvas\");\n      photo = document.createElement(\"img\");\n      startbutton = document.getElementById(\"startbutton\");\n  \n      navigator.mediaDevices.getUserMedia({video: true, audio: false})\n      .then(function(stream) {\n        video.srcObject = stream;\n        video.play();\n      })\n      .catch(function(err) {\n        console.log(\"An error occurred: \" + err);\n      });\n      \n      video.addEventListener('canplay', function(ev){\n        if (!streaming) {\n          height = video.videoHeight / (video.videoWidth/width);\n        \n          // Firefox currently has a bug where the height can't be read from\n          // the video, so we will make assumptions if this happens.\n        \n          if (isNaN(height)) {\n            height = width / (4/3);\n          }\n        \n          video.setAttribute('width', width);\n          video.setAttribute('height', height);\n          canvas.setAttribute('width', width);\n          canvas.setAttribute('height', height);\n          streaming = true;\n        }\n      }, false);\n  \n      startbutton.addEventListener('click', function(ev){\n        takepicture();\n        ev.preventDefault();\n      }, false);\n      \n      clearphoto();\n    }\n  \n    // Fill the photo with an indication that none has been\n    // captured.\n  \n    function clearphoto() {\n      var context = canvas.getContext('2d');\n      context.fillStyle = \"#AAA\";\n      context.fillRect(0, 0, canvas.width, canvas.height);\n  \n      var data = canvas.toDataURL('image/png');\n      photo.setAttribute('src', data);\n    }\n    \n    // Capture a photo by fetching the current contents of the video\n    // and drawing it into a canvas, then converting that to a PNG\n    // format data URL. By drawing it on an offscreen canvas and then\n    // drawing that to the screen, we can change its size and/or apply\n    // other changes before drawing it.\n  \n    function takepicture() {\n      var context = canvas.getContext('2d');\n      if (width && height) {\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n      \n        var data = canvas.toDataURL('image/png');\n        photo.setAttribute('src', data);\n      } else {\n        clearphoto();\n      }\n    }\n  \n    // Set up our event listener to run the startup process\n    // once loading is complete.\n    //window.addEventListener('load', startup, false);\n  //};\n  \n  export default startup\n\n  */\n\n\nconst controls = document.getElementById('controls');\nconsole.log(controls);\nconst cameraOptions = document.querySelector('.video-options>select');\nconsole.log(cameraOptions);\nconst video = document.querySelector('video');\nconsole.log(video);\nconst canvas = document.querySelector('canvas');\nconst screenshotImage = document.querySelector('img');\nconst buttons = [...controls.querySelectorAll('button')];\nlet streamStarted = false;\n\nconst [play, pause, screenshot] = buttons;\n\nconst constraints = {\n  video: {\n    width: {\n      min: 1280,\n      ideal: 1920,\n      max: 2560,\n    },\n    height: {\n      min: 720,\n      ideal: 1080,\n      max: 1440\n    },\n  }\n};\n\ncameraOptions.onchange = () => {\n  const updatedConstraints = {\n    ...constraints,\n    deviceId: {\n      exact: cameraOptions.value\n    }\n  };\n\n  startStream(updatedConstraints);\n};\n\nplay.onclick = () => {\n  if (streamStarted) {\n    video.play();\n    play.classList.add('d-none');\n    pause.classList.remove('d-none');\n    return;\n  }\n  if ('mediaDevices' in navigator && navigator.mediaDevices.getUserMedia) {\n    const updatedConstraints = {\n      ...constraints,\n      deviceId: {\n        exact: cameraOptions.value\n      }\n    };\n    startStream(updatedConstraints);\n  }\n};\n\nconst pauseStream = () => {\n  video.pause();\n  play.classList.remove('d-none');\n  pause.classList.add('d-none');\n};\n\nconst doScreenshot = () => {\n  canvas.width = video.videoWidth;\n  canvas.height = video.videoHeight;\n  canvas.getContext('2d').drawImage(video, 0, 0);\n  screenshotImage.src = canvas.toDataURL('image/webp');\n  screenshotImage.classList.remove('d-none');\n};\n\npause.onclick = pauseStream;\nscreenshot.onclick = doScreenshot;\n\nconst startStream = async (constraints) => {\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  handleStream(stream);\n};\n\n\nconst handleStream = (stream) => {\n  video.srcObject = stream;\n  play.classList.add('d-none');\n  pause.classList.remove('d-none');\n  screenshot.classList.remove('d-none');\n};\n\n\nconst getCameraSelection = async () => {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const videoDevices = devices.filter(device => device.kind === 'videoinput');\n  const options = videoDevices.map(videoDevice => {\n    return `<option value=\"${videoDevice.deviceId}\">${videoDevice.label}</option>`;\n  });\n  cameraOptions.innerHTML = options.join('');\n};\n\ngetCameraSelection();"]},"metadata":{},"sourceType":"module"}