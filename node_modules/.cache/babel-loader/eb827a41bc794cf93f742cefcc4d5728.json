{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { a as attachComponent, d as detachComponent } from './framework-delegate.js';\nimport { s as shallowEqualStringMap } from './helpers.js';\nimport { t as transition } from './index4.js';\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\nconst RouterOutlet = /*@__PURE__*/proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n\n    this.__registerHost();\n\n    this.__attachShadow();\n\n    this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = createEvent(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = createEvent(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n\n    this.mode = getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n\n    this.animated = true;\n  }\n\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n\n    this.gesture = (await import('./swipe-back.js')).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => {\n      var _a;\n\n      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);\n    }, (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, {\n          oneTimeCallback: true\n        }); // Account for rounding errors in JS\n\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        } else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      } else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n\n\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    } catch (e) {\n      console.error(e);\n    }\n\n    unlock();\n    return changed;\n  }\n  /** @internal */\n\n\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation\n    });\n    return {\n      changed,\n      element: this.activeEl\n    };\n  }\n  /** @internal */\n\n\n  async getRouteId() {\n    const active = this.activeEl;\n    return active ? {\n      id: active.tagName,\n      element: active,\n      params: this.activeParams\n    } : undefined;\n  }\n\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {\n      return false;\n    } // attach entering view to DOM\n\n\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params; // commit animation\n\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n\n  async transition(enteringEl, leavingEl) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (leavingEl === enteringEl) {\n      return false;\n    } // emit nav will change event\n\n\n    this.ionNavWillChange.emit();\n    const {\n      el,\n      mode\n    } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || config.get('navAnimation');\n    await transition(Object.assign(Object.assign({\n      mode,\n      animated,\n      enteringEl,\n      leavingEl,\n      baseEl: el,\n      progressCallback: opts.progressAnimation ? ani => {\n        /**\n         * Because this progress callback is called asynchronously\n         * it is possible for the gesture to start and end before\n         * the animation is ever set. In that scenario, we should\n         * immediately call progressEnd so that the transition promise\n         * resolves and the gesture does not get locked up.\n         */\n        if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n          this.gestureOrAnimationInProgress = true;\n          ani.onFinish(() => {\n            this.gestureOrAnimationInProgress = false;\n\n            if (this.swipeHandler) {\n              this.swipeHandler.onEnd(false);\n            }\n          }, {\n            oneTimeCallback: true\n          });\n          /**\n           * Playing animation to beginning\n           * with a duration of 0 prevents\n           * any flickering when the animation\n           * is later cleaned up.\n           */\n\n          ani.progressEnd(0, 0, 0);\n        } else {\n          this.ani = ani;\n        }\n      } : undefined\n    }, opts), {\n      animationBuilder\n    })); // emit nav changed event\n\n    this.ionNavDidChange.emit();\n    return true;\n  }\n\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n\n    if (p !== undefined) {\n      await p;\n    }\n\n    return resolve;\n  }\n\n  render() {\n    return h(\"slot\", null);\n  }\n\n  get el() {\n    return this;\n  }\n\n  static get watchers() {\n    return {\n      \"swipeHandler\": [\"swipeHandlerChanged\"]\n    };\n  }\n\n  static get style() {\n    return routeOutletCss;\n  }\n\n}, [1, \"ion-router-outlet\", {\n  \"mode\": [1025],\n  \"delegate\": [16],\n  \"animated\": [4],\n  \"animation\": [16],\n  \"swipeHandler\": [16],\n  \"commit\": [64],\n  \"setRouteId\": [64],\n  \"getRouteId\": [64]\n}]);\n\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-router-outlet\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, RouterOutlet);\n        }\n\n        break;\n    }\n  });\n}\n\nconst IonRouterOutlet = RouterOutlet;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonRouterOutlet, defineCustomElement };","map":{"version":3,"sources":["/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@ionic/core/components/ion-router-outlet.js"],"names":["proxyCustomElement","HTMLElement","createEvent","h","b","getIonMode","c","config","g","getTimeGivenProgression","a","attachComponent","d","detachComponent","s","shallowEqualStringMap","t","transition","routeOutletCss","RouterOutlet","constructor","__registerHost","__attachShadow","ionNavWillLoad","ionNavWillChange","ionNavDidChange","gestureOrAnimationInProgress","mode","animated","swipeHandlerChanged","gesture","enable","swipeHandler","undefined","connectedCallback","onStart","createSwipeBackGesture","el","canStart","step","_a","ani","progressStep","shouldComplete","dur","onFinish","onEnd","oneTimeCallback","newStepValue","easing","progressEnd","componentWillLoad","emit","disconnectedCallback","destroy","commit","enteringEl","leavingEl","opts","unlock","lock","changed","e","console","error","setRouteId","id","params","direction","animation","setRoot","duration","animationBuilder","element","activeEl","getRouteId","active","tagName","activeParams","component","activeComponent","delegate","getBoolean","get","Object","assign","baseEl","progressCallback","progressAnimation","p","waitPromise","resolve","Promise","r","render","watchers","style","defineCustomElement$1","customElements","components","forEach","define","IonRouterOutlet","defineCustomElement"],"mappings":"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","sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { a as attachComponent, d as detachComponent } from './framework-delegate.js';\nimport { s as shallowEqualStringMap } from './helpers.js';\nimport { t as transition } from './index4.js';\n\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\n\nconst RouterOutlet = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = createEvent(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = createEvent(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await import('./swipe-back.js')).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => { var _a; return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step); }, (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation,\n    });\n    return {\n      changed,\n      element: this.activeEl,\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active\n      ? {\n        id: active.tagName,\n        element: active,\n        params: this.activeParams,\n      }\n      : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || config.get('navAnimation');\n    await transition(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el, progressCallback: opts.progressAnimation\n        ? (ani) => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise((r) => (resolve = r));\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return h(\"slot\", null);\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"swipeHandler\": [\"swipeHandlerChanged\"]\n  }; }\n  static get style() { return routeOutletCss; }\n}, [1, \"ion-router-outlet\", {\n    \"mode\": [1025],\n    \"delegate\": [16],\n    \"animated\": [4],\n    \"animation\": [16],\n    \"swipeHandler\": [16],\n    \"commit\": [64],\n    \"setRouteId\": [64],\n    \"getRouteId\": [64]\n  }]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router-outlet\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RouterOutlet);\n      }\n      break;\n  } });\n}\n\nconst IonRouterOutlet = RouterOutlet;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonRouterOutlet, defineCustomElement };\n"]},"metadata":{},"sourceType":"module"}