{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as raf } from './helpers.js';\nlet animationPrefix;\n/**\n * Web Animations requires hyphenated CSS properties\n * to be written in camelCase when animating\n */\n\nconst processKeyframes = keyframes => {\n  keyframes.forEach(keyframe => {\n    for (const key in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(key)) {\n        const value = keyframe[key];\n\n        if (key === 'easing') {\n          const newKey = 'animation-timing-function';\n          keyframe[newKey] = value;\n          delete keyframe[key];\n        } else {\n          const newKey = convertCamelCaseToHypen(key);\n\n          if (newKey !== key) {\n            keyframe[newKey] = value;\n            delete keyframe[key];\n          }\n        }\n      }\n    }\n  });\n  return keyframes;\n};\n\nconst convertCamelCaseToHypen = str => {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\nconst getAnimationPrefix = el => {\n  if (animationPrefix === undefined) {\n    const supportsUnprefixed = el.style.animationName !== undefined;\n    const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\n    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';\n  }\n\n  return animationPrefix;\n};\n\nconst setStyleProperty = (element, propertyName, value) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.setProperty(prefix + propertyName, value);\n};\n\nconst removeStyleProperty = (element, propertyName) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.removeProperty(prefix + propertyName);\n};\n\nconst animationEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = {\n    passive: true\n  };\n\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n\n  const onTransitionEnd = ev => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n\n  if (el) {\n    el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n    el.addEventListener('animationend', onTransitionEnd, opts);\n\n    unRegTrans = () => {\n      el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n      el.removeEventListener('animationend', onTransitionEnd, opts);\n    };\n  }\n\n  return unregister;\n};\n\nconst generateKeyframeRules = function () {\n  let keyframes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return keyframes.map(keyframe => {\n    const offset = keyframe.offset;\n    const frameString = [];\n\n    for (const property in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(property) && property !== 'offset') {\n        frameString.push(`${property}: ${keyframe[property]};`);\n      }\n    }\n\n    return `${offset * 100}% { ${frameString.join(' ')} }`;\n  }).join(' ');\n};\n\nconst keyframeIds = [];\n\nconst generateKeyframeName = keyframeRules => {\n  let index = keyframeIds.indexOf(keyframeRules);\n\n  if (index < 0) {\n    index = keyframeIds.push(keyframeRules) - 1;\n  }\n\n  return `ion-animation-${index}`;\n};\n\nconst getStyleContainer = element => {\n  const rootNode = element.getRootNode();\n  return rootNode.head || rootNode;\n};\n\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\n  const styleContainer = getStyleContainer(element);\n  const keyframePrefix = getAnimationPrefix(element);\n  const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\n\n  if (existingStylesheet) {\n    return existingStylesheet;\n  }\n\n  const stylesheet = (element.ownerDocument || document).createElement('style');\n  stylesheet.id = keyframeName;\n  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\n  styleContainer.appendChild(stylesheet);\n  return stylesheet;\n};\n\nconst addClassToArray = function () {\n  let classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let className = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (className !== undefined) {\n    const classNameToAppend = Array.isArray(className) ? className : [className];\n    return [...classes, ...classNameToAppend];\n  }\n\n  return classes;\n};\n\nconst createAnimation = animationId => {\n  let _delay;\n\n  let _duration;\n\n  let _easing;\n\n  let _iterations;\n\n  let _fill;\n\n  let _direction;\n\n  let _keyframes = [];\n  let beforeAddClasses = [];\n  let beforeRemoveClasses = [];\n  let initialized = false;\n  let parentAnimation;\n  let beforeStylesValue = {};\n  let afterAddClasses = [];\n  let afterRemoveClasses = [];\n  let afterStylesValue = {};\n  let numAnimationsRunning = 0;\n  let shouldForceLinearEasing = false;\n  let shouldForceSyncPlayback = false;\n  let cssAnimationsTimerFallback;\n  let forceDirectionValue;\n  let forceDurationValue;\n  let forceDelayValue;\n  let willComplete = true;\n  let finished = false;\n  let shouldCalculateNumAnimations = true;\n  let keyframeName;\n  let ani;\n  let paused = false;\n  const id = animationId;\n  const onFinishCallbacks = [];\n  const onFinishOneTimeCallbacks = [];\n  const elements = [];\n  const childAnimations = [];\n  const stylesheets = [];\n  const _beforeAddReadFunctions = [];\n  const _beforeAddWriteFunctions = [];\n  const _afterAddReadFunctions = [];\n  const _afterAddWriteFunctions = [];\n  const webAnimations = [];\n  const supportsAnimationEffect = typeof AnimationEffect === 'function' || typeof window.AnimationEffect === 'function';\n  const supportsWebAnimations = typeof Element === 'function' && typeof Element.prototype.animate === 'function' && supportsAnimationEffect;\n  const ANIMATION_END_FALLBACK_PADDING_MS = 100;\n\n  const getWebAnimations = () => {\n    return webAnimations;\n  };\n\n  const destroy = clearStyleSheets => {\n    childAnimations.forEach(childAnimation => {\n      childAnimation.destroy(clearStyleSheets);\n    });\n    cleanUp(clearStyleSheets);\n    elements.length = 0;\n    childAnimations.length = 0;\n    _keyframes.length = 0;\n    clearOnFinish();\n    initialized = false;\n    shouldCalculateNumAnimations = true;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations, removes\n   * any animation properties from the\n   * animation's elements, and removes the\n   * animation's stylesheets from the DOM.\n   */\n\n\n  const cleanUp = clearStyleSheets => {\n    cleanUpElements();\n\n    if (clearStyleSheets) {\n      cleanUpStyleSheets();\n    }\n  };\n\n  const resetFlags = () => {\n    shouldForceLinearEasing = false;\n    shouldForceSyncPlayback = false;\n    shouldCalculateNumAnimations = true;\n    forceDirectionValue = undefined;\n    forceDurationValue = undefined;\n    forceDelayValue = undefined;\n    numAnimationsRunning = 0;\n    finished = false;\n    willComplete = true;\n    paused = false;\n  };\n\n  const isRunning = () => {\n    return numAnimationsRunning !== 0 && !paused;\n  };\n\n  const onFinish = (callback, opts) => {\n    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\n    callbacks.push({\n      c: callback,\n      o: opts\n    });\n    return ani;\n  };\n\n  const clearOnFinish = () => {\n    onFinishCallbacks.length = 0;\n    onFinishOneTimeCallbacks.length = 0;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations and removes\n   * any animation properties from the\n   * the animation's elements.\n   */\n\n\n  const cleanUpElements = () => {\n    if (supportsWebAnimations) {\n      webAnimations.forEach(animation => {\n        animation.cancel();\n      });\n      webAnimations.length = 0;\n    } else {\n      const elementsArray = elements.slice();\n      raf(() => {\n        elementsArray.forEach(element => {\n          removeStyleProperty(element, 'animation-name');\n          removeStyleProperty(element, 'animation-duration');\n          removeStyleProperty(element, 'animation-timing-function');\n          removeStyleProperty(element, 'animation-iteration-count');\n          removeStyleProperty(element, 'animation-delay');\n          removeStyleProperty(element, 'animation-play-state');\n          removeStyleProperty(element, 'animation-fill-mode');\n          removeStyleProperty(element, 'animation-direction');\n        });\n      });\n    }\n  };\n  /**\n   * Removes the animation's stylesheets\n   * from the DOM.\n   */\n\n\n  const cleanUpStyleSheets = () => {\n    stylesheets.forEach(stylesheet => {\n      /**\n       * When sharing stylesheets, it's possible\n       * for another animation to have already\n       * cleaned up a particular stylesheet\n       */\n      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {\n        stylesheet.parentNode.removeChild(stylesheet);\n      }\n    });\n    stylesheets.length = 0;\n  };\n\n  const beforeAddRead = readFn => {\n    _beforeAddReadFunctions.push(readFn);\n\n    return ani;\n  };\n\n  const beforeAddWrite = writeFn => {\n    _beforeAddWriteFunctions.push(writeFn);\n\n    return ani;\n  };\n\n  const afterAddRead = readFn => {\n    _afterAddReadFunctions.push(readFn);\n\n    return ani;\n  };\n\n  const afterAddWrite = writeFn => {\n    _afterAddWriteFunctions.push(writeFn);\n\n    return ani;\n  };\n\n  const beforeAddClass = className => {\n    beforeAddClasses = addClassToArray(beforeAddClasses, className);\n    return ani;\n  };\n\n  const beforeRemoveClass = className => {\n    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\n    return ani;\n  };\n  /**\n   * Set CSS inline styles to the animation's\n   * elements before the animation begins.\n   */\n\n\n  const beforeStyles = function () {\n    let styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    beforeStylesValue = styles;\n    return ani;\n  };\n  /**\n   * Clear CSS inline styles from the animation's\n   * elements before the animation begins.\n   */\n\n\n  const beforeClearStyles = function () {\n    let propertyNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    for (const property of propertyNames) {\n      beforeStylesValue[property] = '';\n    }\n\n    return ani;\n  };\n\n  const afterAddClass = className => {\n    afterAddClasses = addClassToArray(afterAddClasses, className);\n    return ani;\n  };\n\n  const afterRemoveClass = className => {\n    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\n    return ani;\n  };\n\n  const afterStyles = function () {\n    let styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    afterStylesValue = styles;\n    return ani;\n  };\n\n  const afterClearStyles = function () {\n    let propertyNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    for (const property of propertyNames) {\n      afterStylesValue[property] = '';\n    }\n\n    return ani;\n  };\n\n  const getFill = () => {\n    if (_fill !== undefined) {\n      return _fill;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getFill();\n    }\n\n    return 'both';\n  };\n\n  const getDirection = () => {\n    if (forceDirectionValue !== undefined) {\n      return forceDirectionValue;\n    }\n\n    if (_direction !== undefined) {\n      return _direction;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getDirection();\n    }\n\n    return 'normal';\n  };\n\n  const getEasing = () => {\n    if (shouldForceLinearEasing) {\n      return 'linear';\n    }\n\n    if (_easing !== undefined) {\n      return _easing;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getEasing();\n    }\n\n    return 'linear';\n  };\n\n  const getDuration = () => {\n    if (shouldForceSyncPlayback) {\n      return 0;\n    }\n\n    if (forceDurationValue !== undefined) {\n      return forceDurationValue;\n    }\n\n    if (_duration !== undefined) {\n      return _duration;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getDuration();\n    }\n\n    return 0;\n  };\n\n  const getIterations = () => {\n    if (_iterations !== undefined) {\n      return _iterations;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getIterations();\n    }\n\n    return 1;\n  };\n\n  const getDelay = () => {\n    if (forceDelayValue !== undefined) {\n      return forceDelayValue;\n    }\n\n    if (_delay !== undefined) {\n      return _delay;\n    }\n\n    if (parentAnimation) {\n      return parentAnimation.getDelay();\n    }\n\n    return 0;\n  };\n\n  const getKeyframes = () => {\n    return _keyframes;\n  };\n\n  const direction = animationDirection => {\n    _direction = animationDirection;\n    update(true);\n    return ani;\n  };\n\n  const fill = animationFill => {\n    _fill = animationFill;\n    update(true);\n    return ani;\n  };\n\n  const delay = animationDelay => {\n    _delay = animationDelay;\n    update(true);\n    return ani;\n  };\n\n  const easing = animationEasing => {\n    _easing = animationEasing;\n    update(true);\n    return ani;\n  };\n\n  const duration = animationDuration => {\n    /**\n     * CSS Animation Durations of 0ms work fine on Chrome\n     * but do not run on Safari, so force it to 1ms to\n     * get it to run on both platforms.\n     */\n    if (!supportsWebAnimations && animationDuration === 0) {\n      animationDuration = 1;\n    }\n\n    _duration = animationDuration;\n    update(true);\n    return ani;\n  };\n\n  const iterations = animationIterations => {\n    _iterations = animationIterations;\n    update(true);\n    return ani;\n  };\n\n  const parent = animation => {\n    parentAnimation = animation;\n    return ani;\n  };\n\n  const addElement = el => {\n    if (el != null) {\n      if (el.nodeType === 1) {\n        elements.push(el);\n      } else if (el.length >= 0) {\n        for (let i = 0; i < el.length; i++) {\n          elements.push(el[i]);\n        }\n      } else {\n        console.error('Invalid addElement value');\n      }\n    }\n\n    return ani;\n  };\n\n  const addAnimation = animationToAdd => {\n    if (animationToAdd != null) {\n      if (Array.isArray(animationToAdd)) {\n        for (const animation of animationToAdd) {\n          animation.parent(ani);\n          childAnimations.push(animation);\n        }\n      } else {\n        animationToAdd.parent(ani);\n        childAnimations.push(animationToAdd);\n      }\n    }\n\n    return ani;\n  };\n\n  const keyframes = keyframeValues => {\n    const different = _keyframes !== keyframeValues;\n    _keyframes = keyframeValues;\n\n    if (different) {\n      updateKeyframes(_keyframes);\n    }\n\n    return ani;\n  };\n\n  const updateKeyframes = keyframeValues => {\n    if (supportsWebAnimations) {\n      getWebAnimations().forEach(animation => {\n        if (animation.effect.setKeyframes) {\n          animation.effect.setKeyframes(keyframeValues);\n        } else {\n          const newEffect = new KeyframeEffect(animation.effect.target, keyframeValues, animation.effect.getTiming());\n          animation.effect = newEffect;\n        }\n      });\n    } else {\n      initializeCSSAnimation();\n    }\n  };\n  /**\n   * Run all \"before\" animation hooks.\n   */\n\n\n  const beforeAnimation = () => {\n    // Runs all before read callbacks\n    _beforeAddReadFunctions.forEach(callback => callback()); // Runs all before write callbacks\n\n\n    _beforeAddWriteFunctions.forEach(callback => callback()); // Updates styles and classes before animation runs\n\n\n    const addClasses = beforeAddClasses;\n    const removeClasses = beforeRemoveClasses;\n    const styles = beforeStylesValue;\n    elements.forEach(el => {\n      const elementClassList = el.classList;\n      addClasses.forEach(c => elementClassList.add(c));\n      removeClasses.forEach(c => elementClassList.remove(c));\n\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n  };\n  /**\n   * Run all \"after\" animation hooks.\n   */\n\n\n  const afterAnimation = () => {\n    clearCSSAnimationsTimeout(); // Runs all after read callbacks\n\n    _afterAddReadFunctions.forEach(callback => callback()); // Runs all after write callbacks\n\n\n    _afterAddWriteFunctions.forEach(callback => callback()); // Updates styles and classes before animation ends\n\n\n    const currentStep = willComplete ? 1 : 0;\n    const addClasses = afterAddClasses;\n    const removeClasses = afterRemoveClasses;\n    const styles = afterStylesValue;\n    elements.forEach(el => {\n      const elementClassList = el.classList;\n      addClasses.forEach(c => elementClassList.add(c));\n      removeClasses.forEach(c => elementClassList.remove(c));\n\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n    onFinishCallbacks.forEach(onFinishCallback => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.forEach(onFinishCallback => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.length = 0;\n    shouldCalculateNumAnimations = true;\n\n    if (willComplete) {\n      finished = true;\n    }\n\n    willComplete = true;\n  };\n\n  const animationFinish = () => {\n    if (numAnimationsRunning === 0) {\n      return;\n    }\n\n    numAnimationsRunning--;\n\n    if (numAnimationsRunning === 0) {\n      afterAnimation();\n\n      if (parentAnimation) {\n        parentAnimation.animationFinish();\n      }\n    }\n  };\n\n  const initializeCSSAnimation = function () {\n    let toggleAnimationName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    cleanUpStyleSheets();\n    const processedKeyframes = processKeyframes(_keyframes);\n    elements.forEach(element => {\n      if (processedKeyframes.length > 0) {\n        const keyframeRules = generateKeyframeRules(processedKeyframes);\n        keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);\n        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\n        stylesheets.push(stylesheet);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill());\n        setStyleProperty(element, 'animation-direction', getDirection());\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        setStyleProperty(element, 'animation-play-state', 'paused');\n\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\n        }\n\n        raf(() => {\n          setStyleProperty(element, 'animation-name', stylesheet.id || null);\n        });\n      }\n    });\n  };\n\n  const initializeWebAnimation = () => {\n    elements.forEach(element => {\n      const animation = element.animate(_keyframes, {\n        id,\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection()\n      });\n      animation.pause();\n      webAnimations.push(animation);\n    });\n\n    if (webAnimations.length > 0) {\n      webAnimations[0].onfinish = () => {\n        animationFinish();\n      };\n    }\n  };\n\n  const initializeAnimation = function () {\n    let toggleAnimationName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    beforeAnimation();\n\n    if (_keyframes.length > 0) {\n      if (supportsWebAnimations) {\n        initializeWebAnimation();\n      } else {\n        initializeCSSAnimation(toggleAnimationName);\n      }\n    }\n\n    initialized = true;\n  };\n\n  const setAnimationStep = step => {\n    step = Math.min(Math.max(step, 0), 0.9999);\n\n    if (supportsWebAnimations) {\n      webAnimations.forEach(animation => {\n        animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;\n        animation.pause();\n      });\n    } else {\n      const animationDuration = `-${getDuration() * step}ms`;\n      elements.forEach(element => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-delay', animationDuration);\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        }\n      });\n    }\n  };\n\n  const updateWebAnimation = step => {\n    webAnimations.forEach(animation => {\n      animation.effect.updateTiming({\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection()\n      });\n    });\n\n    if (step !== undefined) {\n      setAnimationStep(step);\n    }\n  };\n\n  const updateCSSAnimation = function () {\n    let toggleAnimationName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let step = arguments.length > 1 ? arguments[1] : undefined;\n    raf(() => {\n      elements.forEach(element => {\n        setStyleProperty(element, 'animation-name', keyframeName || null);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill() || null);\n        setStyleProperty(element, 'animation-direction', getDirection() || null);\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\n        }\n\n        raf(() => {\n          setStyleProperty(element, 'animation-name', keyframeName || null);\n        });\n      });\n    });\n  };\n\n  const update = function () {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let toggleAnimationName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let step = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (deep) {\n      childAnimations.forEach(animation => {\n        animation.update(deep, toggleAnimationName, step);\n      });\n    }\n\n    if (supportsWebAnimations) {\n      updateWebAnimation(step);\n    } else {\n      updateCSSAnimation(toggleAnimationName, step);\n    }\n\n    return ani;\n  };\n\n  const progressStart = function () {\n    let forceLinearEasing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let step = arguments.length > 1 ? arguments[1] : undefined;\n    childAnimations.forEach(animation => {\n      animation.progressStart(forceLinearEasing, step);\n    });\n    pauseAnimation();\n    shouldForceLinearEasing = forceLinearEasing;\n\n    if (!initialized) {\n      initializeAnimation();\n    }\n\n    update(false, true, step);\n    return ani;\n  };\n\n  const progressStep = step => {\n    childAnimations.forEach(animation => {\n      animation.progressStep(step);\n    });\n    setAnimationStep(step);\n    return ani;\n  };\n\n  const progressEnd = (playTo, step, dur) => {\n    shouldForceLinearEasing = false;\n    childAnimations.forEach(animation => {\n      animation.progressEnd(playTo, step, dur);\n    });\n\n    if (dur !== undefined) {\n      forceDurationValue = dur;\n    }\n\n    finished = false;\n    willComplete = true;\n\n    if (playTo === 0) {\n      forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';\n\n      if (forceDirectionValue === 'reverse') {\n        willComplete = false;\n      }\n\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(1 - step);\n      } else {\n        forceDelayValue = (1 - step) * getDuration() * -1;\n        update(false, false);\n      }\n    } else if (playTo === 1) {\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(step);\n      } else {\n        forceDelayValue = step * getDuration() * -1;\n        update(false, false);\n      }\n    }\n\n    if (playTo !== undefined) {\n      onFinish(() => {\n        forceDurationValue = undefined;\n        forceDirectionValue = undefined;\n        forceDelayValue = undefined;\n      }, {\n        oneTimeCallback: true\n      });\n\n      if (!parentAnimation) {\n        play();\n      }\n    }\n\n    return ani;\n  };\n\n  const pauseAnimation = () => {\n    if (initialized) {\n      if (supportsWebAnimations) {\n        webAnimations.forEach(animation => {\n          animation.pause();\n        });\n      } else {\n        elements.forEach(element => {\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        });\n      }\n\n      paused = true;\n    }\n  };\n\n  const pause = () => {\n    childAnimations.forEach(animation => {\n      animation.pause();\n    });\n    pauseAnimation();\n    return ani;\n  };\n\n  const onAnimationEndFallback = () => {\n    cssAnimationsTimerFallback = undefined;\n    animationFinish();\n  };\n\n  const clearCSSAnimationsTimeout = () => {\n    if (cssAnimationsTimerFallback) {\n      clearTimeout(cssAnimationsTimerFallback);\n    }\n  };\n\n  const playCSSAnimations = () => {\n    clearCSSAnimationsTimeout();\n    raf(() => {\n      elements.forEach(element => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-play-state', 'running');\n        }\n      });\n    });\n\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    } else {\n      /**\n       * This is a catchall in the event that a CSS Animation did not finish.\n       * The Web Animations API has mechanisms in place for preventing this.\n       * CSS Animations will not fire an `animationend` event\n       * for elements with `display: none`. The Web Animations API\n       * accounts for this, but using raw CSS Animations requires\n       * this workaround.\n       */\n      const animationDelay = getDelay() || 0;\n      const animationDuration = getDuration() || 0;\n      const animationIterations = getIterations() || 1; // No need to set a timeout when animation has infinite iterations\n\n      if (isFinite(animationIterations)) {\n        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);\n      }\n\n      animationEnd(elements[0], () => {\n        clearCSSAnimationsTimeout();\n        /**\n         * Ensure that clean up\n         * is always done a frame\n         * before the onFinish handlers\n         * are fired. Otherwise, there\n         * may be flickering if a new\n         * animation is started on the same\n         * element too quickly\n         *\n         * TODO: Is there a cleaner way to do this?\n         */\n\n        raf(() => {\n          clearCSSAnimationPlayState();\n          raf(animationFinish);\n        });\n      });\n    }\n  };\n\n  const clearCSSAnimationPlayState = () => {\n    elements.forEach(element => {\n      removeStyleProperty(element, 'animation-duration');\n      removeStyleProperty(element, 'animation-delay');\n      removeStyleProperty(element, 'animation-play-state');\n    });\n  };\n\n  const playWebAnimations = () => {\n    webAnimations.forEach(animation => {\n      animation.play();\n    });\n\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n  };\n\n  const resetAnimation = () => {\n    if (supportsWebAnimations) {\n      setAnimationStep(0);\n      updateWebAnimation();\n    } else {\n      updateCSSAnimation();\n    }\n  };\n\n  const play = opts => {\n    return new Promise(resolve => {\n      if (opts === null || opts === void 0 ? void 0 : opts.sync) {\n        shouldForceSyncPlayback = true;\n        onFinish(() => shouldForceSyncPlayback = false, {\n          oneTimeCallback: true\n        });\n      }\n\n      if (!initialized) {\n        initializeAnimation();\n      }\n\n      if (finished) {\n        resetAnimation();\n        finished = false;\n      }\n\n      if (shouldCalculateNumAnimations) {\n        numAnimationsRunning = childAnimations.length + 1;\n        shouldCalculateNumAnimations = false;\n      }\n\n      onFinish(() => resolve(), {\n        oneTimeCallback: true\n      });\n      childAnimations.forEach(animation => {\n        animation.play();\n      });\n\n      if (supportsWebAnimations) {\n        playWebAnimations();\n      } else {\n        playCSSAnimations();\n      }\n\n      paused = false;\n    });\n  };\n\n  const stop = () => {\n    childAnimations.forEach(animation => {\n      animation.stop();\n    });\n\n    if (initialized) {\n      cleanUpElements();\n      initialized = false;\n    }\n\n    resetFlags();\n  };\n\n  const from = (property, value) => {\n    const firstFrame = _keyframes[0];\n\n    if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\n      firstFrame[property] = value;\n    } else {\n      _keyframes = [{\n        offset: 0,\n        [property]: value\n      }, ..._keyframes];\n    }\n\n    return ani;\n  };\n\n  const to = (property, value) => {\n    const lastFrame = _keyframes[_keyframes.length - 1];\n\n    if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\n      lastFrame[property] = value;\n    } else {\n      _keyframes = [..._keyframes, {\n        offset: 1,\n        [property]: value\n      }];\n    }\n\n    return ani;\n  };\n\n  const fromTo = (property, fromValue, toValue) => {\n    return from(property, fromValue).to(property, toValue);\n  };\n\n  return ani = {\n    parentAnimation,\n    elements,\n    childAnimations,\n    id,\n    animationFinish,\n    from,\n    to,\n    fromTo,\n    parent,\n    play,\n    pause,\n    stop,\n    destroy,\n    keyframes,\n    addAnimation,\n    addElement,\n    update,\n    fill,\n    direction,\n    iterations,\n    duration,\n    easing,\n    delay,\n    getWebAnimations,\n    getKeyframes,\n    getFill,\n    getDirection,\n    getDelay,\n    getIterations,\n    getEasing,\n    getDuration,\n    afterAddRead,\n    afterAddWrite,\n    afterClearStyles,\n    afterStyles,\n    afterRemoveClass,\n    afterAddClass,\n    beforeAddRead,\n    beforeAddWrite,\n    beforeClearStyles,\n    beforeStyles,\n    beforeRemoveClass,\n    beforeAddClass,\n    onFinish,\n    isRunning,\n    progressStart,\n    progressStep,\n    progressEnd\n  };\n};\n\nexport { createAnimation as c };","map":{"version":3,"sources":["/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/node_modules/@ionic/core/components/animation.js"],"names":["r","raf","animationPrefix","processKeyframes","keyframes","forEach","keyframe","key","hasOwnProperty","value","newKey","convertCamelCaseToHypen","str","replace","toLowerCase","getAnimationPrefix","el","undefined","supportsUnprefixed","style","animationName","supportsWebkitPrefix","webkitAnimationName","setStyleProperty","element","propertyName","prefix","startsWith","setProperty","removeStyleProperty","removeProperty","animationEnd","callback","unRegTrans","opts","passive","unregister","onTransitionEnd","ev","target","addEventListener","removeEventListener","generateKeyframeRules","map","offset","frameString","property","push","join","keyframeIds","generateKeyframeName","keyframeRules","index","indexOf","getStyleContainer","rootNode","getRootNode","head","createKeyframeStylesheet","keyframeName","styleContainer","keyframePrefix","existingStylesheet","querySelector","stylesheet","ownerDocument","document","createElement","id","textContent","appendChild","addClassToArray","classes","className","classNameToAppend","Array","isArray","createAnimation","animationId","_delay","_duration","_easing","_iterations","_fill","_direction","_keyframes","beforeAddClasses","beforeRemoveClasses","initialized","parentAnimation","beforeStylesValue","afterAddClasses","afterRemoveClasses","afterStylesValue","numAnimationsRunning","shouldForceLinearEasing","shouldForceSyncPlayback","cssAnimationsTimerFallback","forceDirectionValue","forceDurationValue","forceDelayValue","willComplete","finished","shouldCalculateNumAnimations","ani","paused","onFinishCallbacks","onFinishOneTimeCallbacks","elements","childAnimations","stylesheets","_beforeAddReadFunctions","_beforeAddWriteFunctions","_afterAddReadFunctions","_afterAddWriteFunctions","webAnimations","supportsAnimationEffect","AnimationEffect","window","supportsWebAnimations","Element","prototype","animate","ANIMATION_END_FALLBACK_PADDING_MS","getWebAnimations","destroy","clearStyleSheets","childAnimation","cleanUp","length","clearOnFinish","cleanUpElements","cleanUpStyleSheets","resetFlags","isRunning","onFinish","callbacks","oneTimeCallback","c","o","animation","cancel","elementsArray","slice","parentNode","removeChild","beforeAddRead","readFn","beforeAddWrite","writeFn","afterAddRead","afterAddWrite","beforeAddClass","beforeRemoveClass","beforeStyles","styles","beforeClearStyles","propertyNames","afterAddClass","afterRemoveClass","afterStyles","afterClearStyles","getFill","getDirection","getEasing","getDuration","getIterations","getDelay","getKeyframes","direction","animationDirection","update","fill","animationFill","delay","animationDelay","easing","animationEasing","duration","animationDuration","iterations","animationIterations","parent","addElement","nodeType","i","console","error","addAnimation","animationToAdd","keyframeValues","different","updateKeyframes","effect","setKeyframes","newEffect","KeyframeEffect","getTiming","initializeCSSAnimation","beforeAnimation","addClasses","removeClasses","elementClassList","classList","add","remove","afterAnimation","clearCSSAnimationsTimeout","currentStep","onFinishCallback","animationFinish","toggleAnimationName","processedKeyframes","iterationsCount","Infinity","toString","initializeWebAnimation","pause","onfinish","initializeAnimation","setAnimationStep","step","Math","min","max","currentTime","getComputedTiming","updateWebAnimation","updateTiming","updateCSSAnimation","deep","progressStart","forceLinearEasing","pauseAnimation","progressStep","progressEnd","playTo","dur","play","onAnimationEndFallback","clearTimeout","playCSSAnimations","isFinite","setTimeout","clearCSSAnimationPlayState","playWebAnimations","resetAnimation","Promise","resolve","sync","stop","from","firstFrame","to","lastFrame","fromTo","fromValue","toValue"],"mappings":"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","sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as raf } from './helpers.js';\n\nlet animationPrefix;\n/**\n * Web Animations requires hyphenated CSS properties\n * to be written in camelCase when animating\n */\nconst processKeyframes = (keyframes) => {\n  keyframes.forEach((keyframe) => {\n    for (const key in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(key)) {\n        const value = keyframe[key];\n        if (key === 'easing') {\n          const newKey = 'animation-timing-function';\n          keyframe[newKey] = value;\n          delete keyframe[key];\n        }\n        else {\n          const newKey = convertCamelCaseToHypen(key);\n          if (newKey !== key) {\n            keyframe[newKey] = value;\n            delete keyframe[key];\n          }\n        }\n      }\n    }\n  });\n  return keyframes;\n};\nconst convertCamelCaseToHypen = (str) => {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n};\nconst getAnimationPrefix = (el) => {\n  if (animationPrefix === undefined) {\n    const supportsUnprefixed = el.style.animationName !== undefined;\n    const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\n    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';\n  }\n  return animationPrefix;\n};\nconst setStyleProperty = (element, propertyName, value) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.setProperty(prefix + propertyName, value);\n};\nconst removeStyleProperty = (element, propertyName) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.removeProperty(prefix + propertyName);\n};\nconst animationEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = { passive: true };\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n    el.addEventListener('animationend', onTransitionEnd, opts);\n    unRegTrans = () => {\n      el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n      el.removeEventListener('animationend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\nconst generateKeyframeRules = (keyframes = []) => {\n  return keyframes\n    .map((keyframe) => {\n    const offset = keyframe.offset;\n    const frameString = [];\n    for (const property in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(property) && property !== 'offset') {\n        frameString.push(`${property}: ${keyframe[property]};`);\n      }\n    }\n    return `${offset * 100}% { ${frameString.join(' ')} }`;\n  })\n    .join(' ');\n};\nconst keyframeIds = [];\nconst generateKeyframeName = (keyframeRules) => {\n  let index = keyframeIds.indexOf(keyframeRules);\n  if (index < 0) {\n    index = keyframeIds.push(keyframeRules) - 1;\n  }\n  return `ion-animation-${index}`;\n};\nconst getStyleContainer = (element) => {\n  const rootNode = element.getRootNode();\n  return rootNode.head || rootNode;\n};\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\n  const styleContainer = getStyleContainer(element);\n  const keyframePrefix = getAnimationPrefix(element);\n  const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\n  if (existingStylesheet) {\n    return existingStylesheet;\n  }\n  const stylesheet = (element.ownerDocument || document).createElement('style');\n  stylesheet.id = keyframeName;\n  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\n  styleContainer.appendChild(stylesheet);\n  return stylesheet;\n};\nconst addClassToArray = (classes = [], className) => {\n  if (className !== undefined) {\n    const classNameToAppend = Array.isArray(className) ? className : [className];\n    return [...classes, ...classNameToAppend];\n  }\n  return classes;\n};\n\nconst createAnimation = (animationId) => {\n  let _delay;\n  let _duration;\n  let _easing;\n  let _iterations;\n  let _fill;\n  let _direction;\n  let _keyframes = [];\n  let beforeAddClasses = [];\n  let beforeRemoveClasses = [];\n  let initialized = false;\n  let parentAnimation;\n  let beforeStylesValue = {};\n  let afterAddClasses = [];\n  let afterRemoveClasses = [];\n  let afterStylesValue = {};\n  let numAnimationsRunning = 0;\n  let shouldForceLinearEasing = false;\n  let shouldForceSyncPlayback = false;\n  let cssAnimationsTimerFallback;\n  let forceDirectionValue;\n  let forceDurationValue;\n  let forceDelayValue;\n  let willComplete = true;\n  let finished = false;\n  let shouldCalculateNumAnimations = true;\n  let keyframeName;\n  let ani;\n  let paused = false;\n  const id = animationId;\n  const onFinishCallbacks = [];\n  const onFinishOneTimeCallbacks = [];\n  const elements = [];\n  const childAnimations = [];\n  const stylesheets = [];\n  const _beforeAddReadFunctions = [];\n  const _beforeAddWriteFunctions = [];\n  const _afterAddReadFunctions = [];\n  const _afterAddWriteFunctions = [];\n  const webAnimations = [];\n  const supportsAnimationEffect = typeof AnimationEffect === 'function' || typeof window.AnimationEffect === 'function';\n  const supportsWebAnimations = typeof Element === 'function' &&\n    typeof Element.prototype.animate === 'function' &&\n    supportsAnimationEffect;\n  const ANIMATION_END_FALLBACK_PADDING_MS = 100;\n  const getWebAnimations = () => {\n    return webAnimations;\n  };\n  const destroy = (clearStyleSheets) => {\n    childAnimations.forEach((childAnimation) => {\n      childAnimation.destroy(clearStyleSheets);\n    });\n    cleanUp(clearStyleSheets);\n    elements.length = 0;\n    childAnimations.length = 0;\n    _keyframes.length = 0;\n    clearOnFinish();\n    initialized = false;\n    shouldCalculateNumAnimations = true;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations, removes\n   * any animation properties from the\n   * animation's elements, and removes the\n   * animation's stylesheets from the DOM.\n   */\n  const cleanUp = (clearStyleSheets) => {\n    cleanUpElements();\n    if (clearStyleSheets) {\n      cleanUpStyleSheets();\n    }\n  };\n  const resetFlags = () => {\n    shouldForceLinearEasing = false;\n    shouldForceSyncPlayback = false;\n    shouldCalculateNumAnimations = true;\n    forceDirectionValue = undefined;\n    forceDurationValue = undefined;\n    forceDelayValue = undefined;\n    numAnimationsRunning = 0;\n    finished = false;\n    willComplete = true;\n    paused = false;\n  };\n  const isRunning = () => {\n    return numAnimationsRunning !== 0 && !paused;\n  };\n  const onFinish = (callback, opts) => {\n    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\n    callbacks.push({ c: callback, o: opts });\n    return ani;\n  };\n  const clearOnFinish = () => {\n    onFinishCallbacks.length = 0;\n    onFinishOneTimeCallbacks.length = 0;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations and removes\n   * any animation properties from the\n   * the animation's elements.\n   */\n  const cleanUpElements = () => {\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        animation.cancel();\n      });\n      webAnimations.length = 0;\n    }\n    else {\n      const elementsArray = elements.slice();\n      raf(() => {\n        elementsArray.forEach((element) => {\n          removeStyleProperty(element, 'animation-name');\n          removeStyleProperty(element, 'animation-duration');\n          removeStyleProperty(element, 'animation-timing-function');\n          removeStyleProperty(element, 'animation-iteration-count');\n          removeStyleProperty(element, 'animation-delay');\n          removeStyleProperty(element, 'animation-play-state');\n          removeStyleProperty(element, 'animation-fill-mode');\n          removeStyleProperty(element, 'animation-direction');\n        });\n      });\n    }\n  };\n  /**\n   * Removes the animation's stylesheets\n   * from the DOM.\n   */\n  const cleanUpStyleSheets = () => {\n    stylesheets.forEach((stylesheet) => {\n      /**\n       * When sharing stylesheets, it's possible\n       * for another animation to have already\n       * cleaned up a particular stylesheet\n       */\n      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {\n        stylesheet.parentNode.removeChild(stylesheet);\n      }\n    });\n    stylesheets.length = 0;\n  };\n  const beforeAddRead = (readFn) => {\n    _beforeAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const beforeAddWrite = (writeFn) => {\n    _beforeAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const afterAddRead = (readFn) => {\n    _afterAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const afterAddWrite = (writeFn) => {\n    _afterAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const beforeAddClass = (className) => {\n    beforeAddClasses = addClassToArray(beforeAddClasses, className);\n    return ani;\n  };\n  const beforeRemoveClass = (className) => {\n    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\n    return ani;\n  };\n  /**\n   * Set CSS inline styles to the animation's\n   * elements before the animation begins.\n   */\n  const beforeStyles = (styles = {}) => {\n    beforeStylesValue = styles;\n    return ani;\n  };\n  /**\n   * Clear CSS inline styles from the animation's\n   * elements before the animation begins.\n   */\n  const beforeClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      beforeStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const afterAddClass = (className) => {\n    afterAddClasses = addClassToArray(afterAddClasses, className);\n    return ani;\n  };\n  const afterRemoveClass = (className) => {\n    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\n    return ani;\n  };\n  const afterStyles = (styles = {}) => {\n    afterStylesValue = styles;\n    return ani;\n  };\n  const afterClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      afterStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const getFill = () => {\n    if (_fill !== undefined) {\n      return _fill;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getFill();\n    }\n    return 'both';\n  };\n  const getDirection = () => {\n    if (forceDirectionValue !== undefined) {\n      return forceDirectionValue;\n    }\n    if (_direction !== undefined) {\n      return _direction;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDirection();\n    }\n    return 'normal';\n  };\n  const getEasing = () => {\n    if (shouldForceLinearEasing) {\n      return 'linear';\n    }\n    if (_easing !== undefined) {\n      return _easing;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getEasing();\n    }\n    return 'linear';\n  };\n  const getDuration = () => {\n    if (shouldForceSyncPlayback) {\n      return 0;\n    }\n    if (forceDurationValue !== undefined) {\n      return forceDurationValue;\n    }\n    if (_duration !== undefined) {\n      return _duration;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDuration();\n    }\n    return 0;\n  };\n  const getIterations = () => {\n    if (_iterations !== undefined) {\n      return _iterations;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getIterations();\n    }\n    return 1;\n  };\n  const getDelay = () => {\n    if (forceDelayValue !== undefined) {\n      return forceDelayValue;\n    }\n    if (_delay !== undefined) {\n      return _delay;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDelay();\n    }\n    return 0;\n  };\n  const getKeyframes = () => {\n    return _keyframes;\n  };\n  const direction = (animationDirection) => {\n    _direction = animationDirection;\n    update(true);\n    return ani;\n  };\n  const fill = (animationFill) => {\n    _fill = animationFill;\n    update(true);\n    return ani;\n  };\n  const delay = (animationDelay) => {\n    _delay = animationDelay;\n    update(true);\n    return ani;\n  };\n  const easing = (animationEasing) => {\n    _easing = animationEasing;\n    update(true);\n    return ani;\n  };\n  const duration = (animationDuration) => {\n    /**\n     * CSS Animation Durations of 0ms work fine on Chrome\n     * but do not run on Safari, so force it to 1ms to\n     * get it to run on both platforms.\n     */\n    if (!supportsWebAnimations && animationDuration === 0) {\n      animationDuration = 1;\n    }\n    _duration = animationDuration;\n    update(true);\n    return ani;\n  };\n  const iterations = (animationIterations) => {\n    _iterations = animationIterations;\n    update(true);\n    return ani;\n  };\n  const parent = (animation) => {\n    parentAnimation = animation;\n    return ani;\n  };\n  const addElement = (el) => {\n    if (el != null) {\n      if (el.nodeType === 1) {\n        elements.push(el);\n      }\n      else if (el.length >= 0) {\n        for (let i = 0; i < el.length; i++) {\n          elements.push(el[i]);\n        }\n      }\n      else {\n        console.error('Invalid addElement value');\n      }\n    }\n    return ani;\n  };\n  const addAnimation = (animationToAdd) => {\n    if (animationToAdd != null) {\n      if (Array.isArray(animationToAdd)) {\n        for (const animation of animationToAdd) {\n          animation.parent(ani);\n          childAnimations.push(animation);\n        }\n      }\n      else {\n        animationToAdd.parent(ani);\n        childAnimations.push(animationToAdd);\n      }\n    }\n    return ani;\n  };\n  const keyframes = (keyframeValues) => {\n    const different = _keyframes !== keyframeValues;\n    _keyframes = keyframeValues;\n    if (different) {\n      updateKeyframes(_keyframes);\n    }\n    return ani;\n  };\n  const updateKeyframes = (keyframeValues) => {\n    if (supportsWebAnimations) {\n      getWebAnimations().forEach((animation) => {\n        if (animation.effect.setKeyframes) {\n          animation.effect.setKeyframes(keyframeValues);\n        }\n        else {\n          const newEffect = new KeyframeEffect(animation.effect.target, keyframeValues, animation.effect.getTiming());\n          animation.effect = newEffect;\n        }\n      });\n    }\n    else {\n      initializeCSSAnimation();\n    }\n  };\n  /**\n   * Run all \"before\" animation hooks.\n   */\n  const beforeAnimation = () => {\n    // Runs all before read callbacks\n    _beforeAddReadFunctions.forEach((callback) => callback());\n    // Runs all before write callbacks\n    _beforeAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation runs\n    const addClasses = beforeAddClasses;\n    const removeClasses = beforeRemoveClasses;\n    const styles = beforeStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n  };\n  /**\n   * Run all \"after\" animation hooks.\n   */\n  const afterAnimation = () => {\n    clearCSSAnimationsTimeout();\n    // Runs all after read callbacks\n    _afterAddReadFunctions.forEach((callback) => callback());\n    // Runs all after write callbacks\n    _afterAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation ends\n    const currentStep = willComplete ? 1 : 0;\n    const addClasses = afterAddClasses;\n    const removeClasses = afterRemoveClasses;\n    const styles = afterStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n    onFinishCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.length = 0;\n    shouldCalculateNumAnimations = true;\n    if (willComplete) {\n      finished = true;\n    }\n    willComplete = true;\n  };\n  const animationFinish = () => {\n    if (numAnimationsRunning === 0) {\n      return;\n    }\n    numAnimationsRunning--;\n    if (numAnimationsRunning === 0) {\n      afterAnimation();\n      if (parentAnimation) {\n        parentAnimation.animationFinish();\n      }\n    }\n  };\n  const initializeCSSAnimation = (toggleAnimationName = true) => {\n    cleanUpStyleSheets();\n    const processedKeyframes = processKeyframes(_keyframes);\n    elements.forEach((element) => {\n      if (processedKeyframes.length > 0) {\n        const keyframeRules = generateKeyframeRules(processedKeyframes);\n        keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);\n        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\n        stylesheets.push(stylesheet);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill());\n        setStyleProperty(element, 'animation-direction', getDirection());\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        setStyleProperty(element, 'animation-play-state', 'paused');\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\n        }\n        raf(() => {\n          setStyleProperty(element, 'animation-name', stylesheet.id || null);\n        });\n      }\n    });\n  };\n  const initializeWebAnimation = () => {\n    elements.forEach((element) => {\n      const animation = element.animate(_keyframes, {\n        id,\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n      animation.pause();\n      webAnimations.push(animation);\n    });\n    if (webAnimations.length > 0) {\n      webAnimations[0].onfinish = () => {\n        animationFinish();\n      };\n    }\n  };\n  const initializeAnimation = (toggleAnimationName = true) => {\n    beforeAnimation();\n    if (_keyframes.length > 0) {\n      if (supportsWebAnimations) {\n        initializeWebAnimation();\n      }\n      else {\n        initializeCSSAnimation(toggleAnimationName);\n      }\n    }\n    initialized = true;\n  };\n  const setAnimationStep = (step) => {\n    step = Math.min(Math.max(step, 0), 0.9999);\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;\n        animation.pause();\n      });\n    }\n    else {\n      const animationDuration = `-${getDuration() * step}ms`;\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-delay', animationDuration);\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        }\n      });\n    }\n  };\n  const updateWebAnimation = (step) => {\n    webAnimations.forEach((animation) => {\n      animation.effect.updateTiming({\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n    });\n    if (step !== undefined) {\n      setAnimationStep(step);\n    }\n  };\n  const updateCSSAnimation = (toggleAnimationName = true, step) => {\n    raf(() => {\n      elements.forEach((element) => {\n        setStyleProperty(element, 'animation-name', keyframeName || null);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill() || null);\n        setStyleProperty(element, 'animation-direction', getDirection() || null);\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\n        }\n        raf(() => {\n          setStyleProperty(element, 'animation-name', keyframeName || null);\n        });\n      });\n    });\n  };\n  const update = (deep = false, toggleAnimationName = true, step) => {\n    if (deep) {\n      childAnimations.forEach((animation) => {\n        animation.update(deep, toggleAnimationName, step);\n      });\n    }\n    if (supportsWebAnimations) {\n      updateWebAnimation(step);\n    }\n    else {\n      updateCSSAnimation(toggleAnimationName, step);\n    }\n    return ani;\n  };\n  const progressStart = (forceLinearEasing = false, step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStart(forceLinearEasing, step);\n    });\n    pauseAnimation();\n    shouldForceLinearEasing = forceLinearEasing;\n    if (!initialized) {\n      initializeAnimation();\n    }\n    update(false, true, step);\n    return ani;\n  };\n  const progressStep = (step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStep(step);\n    });\n    setAnimationStep(step);\n    return ani;\n  };\n  const progressEnd = (playTo, step, dur) => {\n    shouldForceLinearEasing = false;\n    childAnimations.forEach((animation) => {\n      animation.progressEnd(playTo, step, dur);\n    });\n    if (dur !== undefined) {\n      forceDurationValue = dur;\n    }\n    finished = false;\n    willComplete = true;\n    if (playTo === 0) {\n      forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';\n      if (forceDirectionValue === 'reverse') {\n        willComplete = false;\n      }\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(1 - step);\n      }\n      else {\n        forceDelayValue = (1 - step) * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    else if (playTo === 1) {\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(step);\n      }\n      else {\n        forceDelayValue = step * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    if (playTo !== undefined) {\n      onFinish(() => {\n        forceDurationValue = undefined;\n        forceDirectionValue = undefined;\n        forceDelayValue = undefined;\n      }, {\n        oneTimeCallback: true,\n      });\n      if (!parentAnimation) {\n        play();\n      }\n    }\n    return ani;\n  };\n  const pauseAnimation = () => {\n    if (initialized) {\n      if (supportsWebAnimations) {\n        webAnimations.forEach((animation) => {\n          animation.pause();\n        });\n      }\n      else {\n        elements.forEach((element) => {\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        });\n      }\n      paused = true;\n    }\n  };\n  const pause = () => {\n    childAnimations.forEach((animation) => {\n      animation.pause();\n    });\n    pauseAnimation();\n    return ani;\n  };\n  const onAnimationEndFallback = () => {\n    cssAnimationsTimerFallback = undefined;\n    animationFinish();\n  };\n  const clearCSSAnimationsTimeout = () => {\n    if (cssAnimationsTimerFallback) {\n      clearTimeout(cssAnimationsTimerFallback);\n    }\n  };\n  const playCSSAnimations = () => {\n    clearCSSAnimationsTimeout();\n    raf(() => {\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-play-state', 'running');\n        }\n      });\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n    else {\n      /**\n       * This is a catchall in the event that a CSS Animation did not finish.\n       * The Web Animations API has mechanisms in place for preventing this.\n       * CSS Animations will not fire an `animationend` event\n       * for elements with `display: none`. The Web Animations API\n       * accounts for this, but using raw CSS Animations requires\n       * this workaround.\n       */\n      const animationDelay = getDelay() || 0;\n      const animationDuration = getDuration() || 0;\n      const animationIterations = getIterations() || 1;\n      // No need to set a timeout when animation has infinite iterations\n      if (isFinite(animationIterations)) {\n        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);\n      }\n      animationEnd(elements[0], () => {\n        clearCSSAnimationsTimeout();\n        /**\n         * Ensure that clean up\n         * is always done a frame\n         * before the onFinish handlers\n         * are fired. Otherwise, there\n         * may be flickering if a new\n         * animation is started on the same\n         * element too quickly\n         *\n         * TODO: Is there a cleaner way to do this?\n         */\n        raf(() => {\n          clearCSSAnimationPlayState();\n          raf(animationFinish);\n        });\n      });\n    }\n  };\n  const clearCSSAnimationPlayState = () => {\n    elements.forEach((element) => {\n      removeStyleProperty(element, 'animation-duration');\n      removeStyleProperty(element, 'animation-delay');\n      removeStyleProperty(element, 'animation-play-state');\n    });\n  };\n  const playWebAnimations = () => {\n    webAnimations.forEach((animation) => {\n      animation.play();\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n  };\n  const resetAnimation = () => {\n    if (supportsWebAnimations) {\n      setAnimationStep(0);\n      updateWebAnimation();\n    }\n    else {\n      updateCSSAnimation();\n    }\n  };\n  const play = (opts) => {\n    return new Promise((resolve) => {\n      if (opts === null || opts === void 0 ? void 0 : opts.sync) {\n        shouldForceSyncPlayback = true;\n        onFinish(() => (shouldForceSyncPlayback = false), { oneTimeCallback: true });\n      }\n      if (!initialized) {\n        initializeAnimation();\n      }\n      if (finished) {\n        resetAnimation();\n        finished = false;\n      }\n      if (shouldCalculateNumAnimations) {\n        numAnimationsRunning = childAnimations.length + 1;\n        shouldCalculateNumAnimations = false;\n      }\n      onFinish(() => resolve(), { oneTimeCallback: true });\n      childAnimations.forEach((animation) => {\n        animation.play();\n      });\n      if (supportsWebAnimations) {\n        playWebAnimations();\n      }\n      else {\n        playCSSAnimations();\n      }\n      paused = false;\n    });\n  };\n  const stop = () => {\n    childAnimations.forEach((animation) => {\n      animation.stop();\n    });\n    if (initialized) {\n      cleanUpElements();\n      initialized = false;\n    }\n    resetFlags();\n  };\n  const from = (property, value) => {\n    const firstFrame = _keyframes[0];\n    if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\n      firstFrame[property] = value;\n    }\n    else {\n      _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];\n    }\n    return ani;\n  };\n  const to = (property, value) => {\n    const lastFrame = _keyframes[_keyframes.length - 1];\n    if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\n      lastFrame[property] = value;\n    }\n    else {\n      _keyframes = [..._keyframes, { offset: 1, [property]: value }];\n    }\n    return ani;\n  };\n  const fromTo = (property, fromValue, toValue) => {\n    return from(property, fromValue).to(property, toValue);\n  };\n  return (ani = {\n    parentAnimation,\n    elements,\n    childAnimations,\n    id,\n    animationFinish,\n    from,\n    to,\n    fromTo,\n    parent,\n    play,\n    pause,\n    stop,\n    destroy,\n    keyframes,\n    addAnimation,\n    addElement,\n    update,\n    fill,\n    direction,\n    iterations,\n    duration,\n    easing,\n    delay,\n    getWebAnimations,\n    getKeyframes,\n    getFill,\n    getDirection,\n    getDelay,\n    getIterations,\n    getEasing,\n    getDuration,\n    afterAddRead,\n    afterAddWrite,\n    afterClearStyles,\n    afterStyles,\n    afterRemoveClass,\n    afterAddClass,\n    beforeAddRead,\n    beforeAddWrite,\n    beforeClearStyles,\n    beforeStyles,\n    beforeRemoveClass,\n    beforeAddClass,\n    onFinish,\n    isRunning,\n    progressStart,\n    progressStep,\n    progressEnd,\n  });\n};\n\nexport { createAnimation as c };\n"]},"metadata":{},"sourceType":"module"}