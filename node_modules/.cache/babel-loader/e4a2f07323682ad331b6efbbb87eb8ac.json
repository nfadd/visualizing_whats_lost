{"ast":null,"code":"/*\nfunction Camera() {\n    return(\n        <div className='camera'>\n            <label>\n                <input  id=\"camera\"\n                        style={{display: 'none'}}\n                        type=\"file\" \n                        accept=\"image/*\"\n                        capture=\"camera\"\n                        onChange={readURL(this)}\n                />\n                Camera\n            </label>\n        </div>\n    );\n}\n\nfunction saveImage() {\n    const input = document.getElementById('camera');\n\n    if (input != null){\n        input.onchange = (function(e) {\n            const file = e.path[0].files[0];\n            var image = document.createElement('img');\n            const reader = new FileReader();\n\n            reader.onload = function(event) {\n                image.src = event.target.result;\n            };\n\n            reader.readAsDataURL(file);\n            document.getElementById(\"popup\").appendChild(image);\n        });\n    }\n}\n\nfunction readURL(input){\n    var image = document.createElement('img');\n\n    //console.log(input);\n    \n    if (input !== undefined) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n            image.src = e.target.result;\n        }\n       \n        reader.readAsDataURL(input.files[0]);\n        document.getElementById(\"popup\").appendChild(image);\n    }\n}\n\n*/\n\n/*\nfunction CameraContainer() {\n    return (\n        <div>\n            <button id=\"camera\">Camera</button>\n            <video autoplay></video>\n            <script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"></script>\n        </div>\n    )\n}\n\nfunction CameraOnClick() {\n    document.querySelector('#camera').addEventListener('click', async function init(e) {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: true\n          })\n          const videoTracks = stream.getVideoTracks()\n          const track = videoTracks[0]\n          alert(`Getting video from: ${track.label}`)\n          document.querySelector('video').srcObject = stream\n          document.querySelector('#camera').setAttribute('hidden', true)\n        } catch (error) {\n          alert(`${error.name}`)\n          console.error(error)\n        }\n    })\n}\n\nvar takePhotoButton = document.querySelector('button#takePhoto');\nvar canvas = document.querySelector('canvas');\n\ntakePhotoButton.onclick = takePhoto;\n\n// Get a Blob from the currently selected camera source and\n// display this with an img element.\nfunction takePhoto() {\n  imageCapture.takePhoto().then(function(blob) {\n    console.log('Took photo:', blob);\n    img.classList.remove('hidden');\n    img.src = URL.createObjectURL(blob);\n  }).catch(function(error) {\n    console.log('takePhoto() error: ', error);\n  });\n}\n\nexport default Camera\n*/\n\n/*\n//const Camera = () => {\n    // The width and height of the captured photo. We will set the\n    // width to the value defined here, but the height will be\n    // calculated based on the aspect ratio of the input stream.\n  \n    var width = 320;    // We will scale the photo width to this\n    var height = 0;     // This will be computed based on the input stream\n  \n    // |streaming| indicates whether or not we're currently streaming\n    // video from the camera. Obviously, we start at false.\n  \n    var streaming = false;\n  \n    // The various HTML elements we need to configure or control. These\n    // will be set by the startup() function.\n  \n    var video = null;\n    var canvas = null;\n    var photo = null;\n    var startbutton = null;\n  \n    function startup() {\n      video = document.getElementById(\"video\");\n      canvas = document.createElement(\"canvas\");\n      photo = document.createElement(\"img\");\n      startbutton = document.getElementById(\"startbutton\");\n  \n      navigator.mediaDevices.getUserMedia({video: true, audio: false})\n      .then(function(stream) {\n        video.srcObject = stream;\n        video.play();\n      })\n      .catch(function(err) {\n        console.log(\"An error occurred: \" + err);\n      });\n      \n      video.addEventListener('canplay', function(ev){\n        if (!streaming) {\n          height = video.videoHeight / (video.videoWidth/width);\n        \n          // Firefox currently has a bug where the height can't be read from\n          // the video, so we will make assumptions if this happens.\n        \n          if (isNaN(height)) {\n            height = width / (4/3);\n          }\n        \n          video.setAttribute('width', width);\n          video.setAttribute('height', height);\n          canvas.setAttribute('width', width);\n          canvas.setAttribute('height', height);\n          streaming = true;\n        }\n      }, false);\n  \n      startbutton.addEventListener('click', function(ev){\n        takepicture();\n        ev.preventDefault();\n      }, false);\n      \n      clearphoto();\n    }\n  \n    // Fill the photo with an indication that none has been\n    // captured.\n  \n    function clearphoto() {\n      var context = canvas.getContext('2d');\n      context.fillStyle = \"#AAA\";\n      context.fillRect(0, 0, canvas.width, canvas.height);\n  \n      var data = canvas.toDataURL('image/png');\n      photo.setAttribute('src', data);\n    }\n    \n    // Capture a photo by fetching the current contents of the video\n    // and drawing it into a canvas, then converting that to a PNG\n    // format data URL. By drawing it on an offscreen canvas and then\n    // drawing that to the screen, we can change its size and/or apply\n    // other changes before drawing it.\n  \n    function takepicture() {\n      var context = canvas.getContext('2d');\n      if (width && height) {\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n      \n        var data = canvas.toDataURL('image/png');\n        photo.setAttribute('src', data);\n      } else {\n        clearphoto();\n      }\n    }\n  \n    // Set up our event listener to run the startup process\n    // once loading is complete.\n    //window.addEventListener('load', startup, false);\n  //};\n  \n  export default startup\n\n  */\nfunction Camera() {\n  const controls = document.querySelector('controls');\n  console.log(controls);\n  const cameraOptions = document.querySelector('.video-options>select');\n  console.log(cameraOptions);\n  const video = document.querySelector('video');\n  console.log(video);\n  const canvas = document.querySelector('canvas');\n  const screenshotImage = document.querySelector('img');\n  const buttons = [...controls.querySelectorAll('button')];\n  let streamStarted = false;\n  const [play, pause, screenshot] = buttons;\n  const constraints = {\n    video: {\n      width: {\n        min: 1280,\n        ideal: 1920,\n        max: 2560\n      },\n      height: {\n        min: 720,\n        ideal: 1080,\n        max: 1440\n      }\n    }\n  };\n\n  cameraOptions.onchange = () => {\n    const updatedConstraints = { ...constraints,\n      deviceId: {\n        exact: cameraOptions.value\n      }\n    };\n    startStream(updatedConstraints);\n  };\n\n  play.onclick = () => {\n    if (streamStarted) {\n      video.play();\n      play.classList.add('d-none');\n      pause.classList.remove('d-none');\n      return;\n    }\n\n    if ('mediaDevices' in navigator && navigator.mediaDevices.getUserMedia) {\n      const updatedConstraints = { ...constraints,\n        deviceId: {\n          exact: cameraOptions.value\n        }\n      };\n      startStream(updatedConstraints);\n    }\n  };\n\n  const pauseStream = () => {\n    video.pause();\n    play.classList.remove('d-none');\n    pause.classList.add('d-none');\n  };\n\n  const doScreenshot = () => {\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    canvas.getContext('2d').drawImage(video, 0, 0);\n    screenshotImage.src = canvas.toDataURL('image/webp');\n    screenshotImage.classList.remove('d-none');\n  };\n\n  pause.onclick = pauseStream;\n  screenshot.onclick = doScreenshot;\n\n  const startStream = async constraints => {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    handleStream(stream);\n  };\n\n  const handleStream = stream => {\n    video.srcObject = stream;\n    play.classList.add('d-none');\n    pause.classList.remove('d-none');\n    screenshot.classList.remove('d-none');\n  };\n\n  const getCameraSelection = async () => {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const videoDevices = devices.filter(device => device.kind === 'videoinput');\n    const options = videoDevices.map(videoDevice => {\n      return `<option value=\"${videoDevice.deviceId}\">${videoDevice.label}</option>`;\n    });\n    cameraOptions.innerHTML = options.join('');\n  };\n\n  getCameraSelection();\n}\n\n_c = Camera;\nexport default Camera;\n\nvar _c;\n\n$RefreshReg$(_c, \"Camera\");","map":{"version":3,"sources":["/Users/nickfaddis/Desktop/SLU/csCapstone/visualizing_whats_lost/react-capacitor-example/src/Camera.js"],"names":["Camera","controls","document","querySelector","console","log","cameraOptions","video","canvas","screenshotImage","buttons","querySelectorAll","streamStarted","play","pause","screenshot","constraints","width","min","ideal","max","height","onchange","updatedConstraints","deviceId","exact","value","startStream","onclick","classList","add","remove","navigator","mediaDevices","getUserMedia","pauseStream","doScreenshot","videoWidth","videoHeight","getContext","drawImage","src","toDataURL","stream","handleStream","srcObject","getCameraSelection","devices","enumerateDevices","videoDevices","filter","device","kind","options","map","videoDevice","label","innerHTML","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,MAAT,GAAmB;AACjB,QAAMC,QAAQ,GAAGC,QAAQ,CAACC,aAAT,CAAuB,UAAvB,CAAjB;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYJ,QAAZ;AACA,QAAMK,aAAa,GAAGJ,QAAQ,CAACC,aAAT,CA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","sourcesContent":["/*\nfunction Camera() {\n    return(\n        <div className='camera'>\n            <label>\n                <input  id=\"camera\"\n                        style={{display: 'none'}}\n                        type=\"file\" \n                        accept=\"image/*\"\n                        capture=\"camera\"\n                        onChange={readURL(this)}\n                />\n                Camera\n            </label>\n        </div>\n    );\n}\n\nfunction saveImage() {\n    const input = document.getElementById('camera');\n\n    if (input != null){\n        input.onchange = (function(e) {\n            const file = e.path[0].files[0];\n            var image = document.createElement('img');\n            const reader = new FileReader();\n\n            reader.onload = function(event) {\n                image.src = event.target.result;\n            };\n\n            reader.readAsDataURL(file);\n            document.getElementById(\"popup\").appendChild(image);\n        });\n    }\n}\n\nfunction readURL(input){\n    var image = document.createElement('img');\n\n    //console.log(input);\n    \n    if (input !== undefined) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n            image.src = e.target.result;\n        }\n       \n        reader.readAsDataURL(input.files[0]);\n        document.getElementById(\"popup\").appendChild(image);\n    }\n}\n\n*/\n\n/*\nfunction CameraContainer() {\n    return (\n        <div>\n            <button id=\"camera\">Camera</button>\n            <video autoplay></video>\n            <script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"></script>\n        </div>\n    )\n}\n\nfunction CameraOnClick() {\n    document.querySelector('#camera').addEventListener('click', async function init(e) {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: true\n          })\n          const videoTracks = stream.getVideoTracks()\n          const track = videoTracks[0]\n          alert(`Getting video from: ${track.label}`)\n          document.querySelector('video').srcObject = stream\n          document.querySelector('#camera').setAttribute('hidden', true)\n        } catch (error) {\n          alert(`${error.name}`)\n          console.error(error)\n        }\n    })\n}\n\nvar takePhotoButton = document.querySelector('button#takePhoto');\nvar canvas = document.querySelector('canvas');\n\ntakePhotoButton.onclick = takePhoto;\n\n// Get a Blob from the currently selected camera source and\n// display this with an img element.\nfunction takePhoto() {\n  imageCapture.takePhoto().then(function(blob) {\n    console.log('Took photo:', blob);\n    img.classList.remove('hidden');\n    img.src = URL.createObjectURL(blob);\n  }).catch(function(error) {\n    console.log('takePhoto() error: ', error);\n  });\n}\n\nexport default Camera\n*/\n\n\n\n\n\n/*\n//const Camera = () => {\n    // The width and height of the captured photo. We will set the\n    // width to the value defined here, but the height will be\n    // calculated based on the aspect ratio of the input stream.\n  \n    var width = 320;    // We will scale the photo width to this\n    var height = 0;     // This will be computed based on the input stream\n  \n    // |streaming| indicates whether or not we're currently streaming\n    // video from the camera. Obviously, we start at false.\n  \n    var streaming = false;\n  \n    // The various HTML elements we need to configure or control. These\n    // will be set by the startup() function.\n  \n    var video = null;\n    var canvas = null;\n    var photo = null;\n    var startbutton = null;\n  \n    function startup() {\n      video = document.getElementById(\"video\");\n      canvas = document.createElement(\"canvas\");\n      photo = document.createElement(\"img\");\n      startbutton = document.getElementById(\"startbutton\");\n  \n      navigator.mediaDevices.getUserMedia({video: true, audio: false})\n      .then(function(stream) {\n        video.srcObject = stream;\n        video.play();\n      })\n      .catch(function(err) {\n        console.log(\"An error occurred: \" + err);\n      });\n      \n      video.addEventListener('canplay', function(ev){\n        if (!streaming) {\n          height = video.videoHeight / (video.videoWidth/width);\n        \n          // Firefox currently has a bug where the height can't be read from\n          // the video, so we will make assumptions if this happens.\n        \n          if (isNaN(height)) {\n            height = width / (4/3);\n          }\n        \n          video.setAttribute('width', width);\n          video.setAttribute('height', height);\n          canvas.setAttribute('width', width);\n          canvas.setAttribute('height', height);\n          streaming = true;\n        }\n      }, false);\n  \n      startbutton.addEventListener('click', function(ev){\n        takepicture();\n        ev.preventDefault();\n      }, false);\n      \n      clearphoto();\n    }\n  \n    // Fill the photo with an indication that none has been\n    // captured.\n  \n    function clearphoto() {\n      var context = canvas.getContext('2d');\n      context.fillStyle = \"#AAA\";\n      context.fillRect(0, 0, canvas.width, canvas.height);\n  \n      var data = canvas.toDataURL('image/png');\n      photo.setAttribute('src', data);\n    }\n    \n    // Capture a photo by fetching the current contents of the video\n    // and drawing it into a canvas, then converting that to a PNG\n    // format data URL. By drawing it on an offscreen canvas and then\n    // drawing that to the screen, we can change its size and/or apply\n    // other changes before drawing it.\n  \n    function takepicture() {\n      var context = canvas.getContext('2d');\n      if (width && height) {\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n      \n        var data = canvas.toDataURL('image/png');\n        photo.setAttribute('src', data);\n      } else {\n        clearphoto();\n      }\n    }\n  \n    // Set up our event listener to run the startup process\n    // once loading is complete.\n    //window.addEventListener('load', startup, false);\n  //};\n  \n  export default startup\n\n  */\n\nfunction Camera () {\n  const controls = document.querySelector('controls');\n  console.log(controls);\n  const cameraOptions = document.querySelector('.video-options>select');\n  console.log(cameraOptions);\n  const video = document.querySelector('video');\n  console.log(video);\n  const canvas = document.querySelector('canvas');\n  const screenshotImage = document.querySelector('img');\n  const buttons = [...controls.querySelectorAll('button')];\n  let streamStarted = false;\n\n  const [play, pause, screenshot] = buttons;\n\n  const constraints = {\n    video: {\n      width: {\n        min: 1280,\n        ideal: 1920,\n        max: 2560,\n      },\n      height: {\n        min: 720,\n        ideal: 1080,\n        max: 1440\n      },\n    }\n  };\n\n  cameraOptions.onchange = () => {\n    const updatedConstraints = {\n      ...constraints,\n      deviceId: {\n        exact: cameraOptions.value\n      }\n    };\n\n    startStream(updatedConstraints);\n  };\n\n  play.onclick = () => {\n    if (streamStarted) {\n      video.play();\n      play.classList.add('d-none');\n      pause.classList.remove('d-none');\n      return;\n    }\n    if ('mediaDevices' in navigator && navigator.mediaDevices.getUserMedia) {\n      const updatedConstraints = {\n        ...constraints,\n        deviceId: {\n          exact: cameraOptions.value\n        }\n      };\n      startStream(updatedConstraints);\n    }\n  };\n\n  const pauseStream = () => {\n    video.pause();\n    play.classList.remove('d-none');\n    pause.classList.add('d-none');\n  };\n\n  const doScreenshot = () => {\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    canvas.getContext('2d').drawImage(video, 0, 0);\n    screenshotImage.src = canvas.toDataURL('image/webp');\n    screenshotImage.classList.remove('d-none');\n  };\n\n  pause.onclick = pauseStream;\n  screenshot.onclick = doScreenshot;\n\n  const startStream = async (constraints) => {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    handleStream(stream);\n  };\n\n\n  const handleStream = (stream) => {\n    video.srcObject = stream;\n    play.classList.add('d-none');\n    pause.classList.remove('d-none');\n    screenshot.classList.remove('d-none');\n  };\n\n\n  const getCameraSelection = async () => {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const videoDevices = devices.filter(device => device.kind === 'videoinput');\n    const options = videoDevices.map(videoDevice => {\n      return `<option value=\"${videoDevice.deviceId}\">${videoDevice.label}</option>`;\n    });\n    cameraOptions.innerHTML = options.join('');\n  };\n\n  getCameraSelection();\n}\n\nexport default Camera;"]},"metadata":{},"sourceType":"module"}